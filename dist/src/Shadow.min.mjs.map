{"version":3,"file":"Shadow.min.mjs","sources":["../../src/Shadow.ts"],"sourcesContent":["import { classRegistry } from './ClassRegistry';\nimport { Color } from './color/Color';\nimport { config } from './config';\nimport { reNum } from './parser/constants';\nimport { Point } from './Point';\nimport type { FabricObject } from './shapes/Object/FabricObject';\nimport type { TClassProperties } from './typedefs';\nimport { uid } from './util/internals/uid';\nimport { pickBy } from './util/misc/pick';\nimport { degreesToRadians } from './util/misc/radiansDegreesConversion';\nimport { toFixed } from './util/misc/toFixed';\nimport { rotateVector } from './util/misc/vectors';\n\n/**\n   * Regex matching shadow offsetX, offsetY and blur (ex: \"2px 2px 10px rgba(0,0,0,0.2)\", \"rgb(0,255,0) 2px 2px\")\n   * - (?:\\s|^): This part captures either a whitespace character (\\s) or the beginning of a line (^). It's non-capturing (due to (?:...)), meaning it doesn't create a capturing group.\n   * - (-?\\d+(?:\\.\\d*)?(?:px)?(?:\\s?|$))?: This captures the first component of the shadow, which is the horizontal offset. Breaking it down:\n   *   - (-?\\d+): Captures an optional minus sign followed by one or more digits (integer part of the number).\n   *   - (?:\\.\\d*)?: Optionally captures a decimal point followed by zero or more digits (decimal part of the number).\n   *   - (?:px)?: Optionally captures the \"px\" unit.\n   *   - (?:\\s?|$): Captures either an optional whitespace or the end of the line. This whole part is wrapped in a non-capturing group and marked as optional with ?.\n   * - (-?\\d+(?:\\.\\d*)?(?:px)?(?:\\s?|$))?: Similar to the previous step, this captures the vertical offset.\n\n(\\d+(?:\\.\\d*)?(?:px)?)?: This captures the blur radius. It's similar to the horizontal offset but without the optional minus sign.\n\n(?:\\s+(-?\\d+(?:\\.\\d*)?(?:px)?(?:\\s?|$))?){0,1}: This captures an optional part for the color. It allows for whitespace followed by a component with an optional minus sign, digits, decimal point, and \"px\" unit.\n\n(?:$|\\s): This captures either the end of the line or a whitespace character. It ensures that the match ends either at the end of the string or with a whitespace character.\n   */\n\nexport enum ShadowOrGlowType {\n  LIGHT_SHADOW = 'light_shadow',\n  STRONG_SHADOW = 'strong_shadow',\n  CUSTOM_SHADOW = 'custom_shadow',\n  LIGHT_GLOW = 'light_glow',\n  STRONG_GLOW = 'strong_glow',\n  NONE = 'none'\n}\n\nconst shadowOffsetRegex = '(-?\\\\d+(?:\\\\.\\\\d*)?(?:px)?(?:\\\\s?|$))?';\n\nconst reOffsetsAndBlur = new RegExp(\n  '(?:\\\\s|^)' +\n    shadowOffsetRegex +\n    shadowOffsetRegex +\n    '(' +\n    reNum +\n    '?(?:px)?)?(?:\\\\s?|$)(?:$|\\\\s)',\n);\n\nexport const shadowDefaultValues: Partial<TClassProperties<Shadow>> = {\n  color: 'rgb(0,0,0)',\n  blur: 0,\n  offsetX: 0,\n  offsetY: 0,\n  affectStroke: false,\n  includeDefaultValues: true,\n  nonScaling: false,\n  shadowOrGlowType : ShadowOrGlowType.NONE\n};\n\nexport type SerializedShadowOptions = {\n  color: string;\n  blur: number;\n  offsetX: number;\n  offsetY: number;\n  affectStroke: boolean;\n  nonScaling: boolean;\n  type: string;\n  shadowOrGlowType: ShadowOrGlowType;\n};\n\nexport class Shadow {\n  /**\n   * Shadow color\n   * @type String\n   * @default\n   */\n  declare color: string;\n\n  /**\n   * Shadow blur\n   * @type Number\n   */\n  declare blur: number;\n\n  /**\n   * Shadow horizontal offset\n   * @type Number\n   * @default\n   */\n  declare offsetX: number;\n\n  /**\n   * Shadow vertical offset\n   * @type Number\n   * @default\n   */\n  declare offsetY: number;\n\n  /**\n   * Whether the shadow should affect stroke operations\n   * @type Boolean\n   * @default\n   */\n  declare affectStroke: boolean;\n\n  /**\n   * Indicates whether toObject should include default values\n   * @type Boolean\n   * @default\n   */\n  declare includeDefaultValues: boolean;\n\n  /**\n   * When `false`, the shadow will scale with the object.\n   * When `true`, the shadow's offsetX, offsetY, and blur will not be affected by the object's scale.\n   * default to false\n   * @type Boolean\n   * @default\n   */\n  declare nonScaling: boolean;\n\n  declare id: number;\n\n  declare shadowOrGlowType: ShadowOrGlowType;\n\n  static ownDefaults = shadowDefaultValues;\n\n  static type = 'shadow';\n\n  /**\n   * @see {@link http://fabricjs.com/shadows|Shadow demo}\n   * @param {Object|String} [options] Options object with any of color, blur, offsetX, offsetY properties or string (e.g. \"rgba(0,0,0,0.2) 2px 2px 10px\")\n   */\n  constructor(options?: Partial<TClassProperties<Shadow>>);\n  constructor(svgAttribute: string);\n  constructor(arg0: string | Partial<TClassProperties<Shadow>> = {}) {\n    const options: Partial<TClassProperties<Shadow>> =\n      typeof arg0 === 'string' ? Shadow.parseShadow(arg0) : arg0;\n    Object.assign(this, Shadow.ownDefaults, options);\n    this.id = uid();\n  }\n\n  /**\n   * @param {String} value Shadow value to parse\n   * @return {Object} Shadow object with color, offsetX, offsetY and blur\n   */\n  static parseShadow(value: string) {\n    const shadowStr = value.trim(),\n      [, offsetX = 0, offsetY = 0, blur = 0] = (\n        reOffsetsAndBlur.exec(shadowStr) || []\n      ).map((value) => parseFloat(value) || 0),\n      color = (shadowStr.replace(reOffsetsAndBlur, '') || 'rgb(0,0,0)').trim();\n\n    return {\n      color,\n      offsetX,\n      offsetY,\n      blur,\n    };\n  }\n\n  isShadow(): boolean {\n    return this.shadowOrGlowType === ShadowOrGlowType.STRONG_SHADOW || this.shadowOrGlowType === ShadowOrGlowType.LIGHT_SHADOW || this.shadowOrGlowType === ShadowOrGlowType.CUSTOM_SHADOW;\n  }\n\n  isCustomShadow(): boolean {\n    return this.shadowOrGlowType === ShadowOrGlowType.CUSTOM_SHADOW;\n  }\n\n  isGlow(): boolean {\n    return this.shadowOrGlowType === ShadowOrGlowType.LIGHT_GLOW || this.shadowOrGlowType === ShadowOrGlowType.STRONG_GLOW;\n  }\n\n  /**\n   * Returns a string representation of an instance\n   * @see http://www.w3.org/TR/css-text-decor-3/#text-shadow\n   * @return {String} Returns CSS3 text-shadow declaration\n   */\n  toString() {\n    return [this.offsetX, this.offsetY, this.blur, this.color].join('px ');\n  }\n\n  /**\n   * Returns SVG representation of a shadow\n   * @param {FabricObject} object\n   * @return {String} SVG representation of a shadow\n   */\n  toSVG(object: FabricObject) {\n    const offset = rotateVector(\n        new Point(this.offsetX, this.offsetY),\n        degreesToRadians(-object.angle),\n      ),\n      BLUR_BOX = 20,\n      color = new Color(this.color);\n    let fBoxX = 40,\n      fBoxY = 40;\n\n    if (object.width && object.height) {\n      //http://www.w3.org/TR/SVG/filters.html#FilterEffectsRegion\n      // we add some extra space to filter box to contain the blur ( 20 )\n      fBoxX =\n        toFixed(\n          (Math.abs(offset.x) + this.blur) / object.width,\n          config.NUM_FRACTION_DIGITS,\n        ) *\n          100 +\n        BLUR_BOX;\n      fBoxY =\n        toFixed(\n          (Math.abs(offset.y) + this.blur) / object.height,\n          config.NUM_FRACTION_DIGITS,\n        ) *\n          100 +\n        BLUR_BOX;\n    }\n    if (object.flipX) {\n      offset.x *= -1;\n    }\n    if (object.flipY) {\n      offset.y *= -1;\n    }\n\n    return `<filter id=\"SVGID_${this.id}\" y=\"-${fBoxY}%\" height=\"${\n      100 + 2 * fBoxY\n    }%\" x=\"-${fBoxX}%\" width=\"${\n      100 + 2 * fBoxX\n    }%\" >\\n\\t<feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"${toFixed(\n      this.blur ? this.blur / 2 : 0,\n      config.NUM_FRACTION_DIGITS,\n    )}\"></feGaussianBlur>\\n\\t<feOffset dx=\"${toFixed(\n      offset.x,\n      config.NUM_FRACTION_DIGITS,\n    )}\" dy=\"${toFixed(\n      offset.y,\n      config.NUM_FRACTION_DIGITS,\n    )}\" result=\"oBlur\" ></feOffset>\\n\\t<feFlood flood-color=\"${color.toRgb()}\" flood-opacity=\"${color.getAlpha()}\"/>\\n\\t<feComposite in2=\"oBlur\" operator=\"in\" />\\n\\t<feMerge>\\n\\t\\t<feMergeNode></feMergeNode>\\n\\t\\t<feMergeNode in=\"SourceGraphic\"></feMergeNode>\\n\\t</feMerge>\\n</filter>\\n`;\n  }\n\n  /**\n   * Returns object representation of a shadow\n   * @return {Object} Object representation of a shadow instance\n   */\n  toObject() {\n    const data: SerializedShadowOptions = {\n      color: this.color,\n      blur: this.blur,\n      offsetX: this.offsetX,\n      offsetY: this.offsetY,\n      affectStroke: this.affectStroke,\n      nonScaling: this.nonScaling,\n      type: (this.constructor as typeof Shadow).type,\n      shadowOrGlowType: this.shadowOrGlowType\n    };\n    const defaults = Shadow.ownDefaults as SerializedShadowOptions;\n    return !this.includeDefaultValues\n      ? pickBy(data, (value, key) => value !== defaults[key])\n      : data;\n  }\n\n  static async fromObject(options: Partial<TClassProperties<Shadow>>) {\n    return new this(options);\n  }\n}\n\nclassRegistry.setClass(Shadow, 'shadow');\n"],"names":["ShadowOrGlowType","shadowOffsetRegex","reOffsetsAndBlur","RegExp","reNum","shadowDefaultValues","color","blur","offsetX","offsetY","affectStroke","includeDefaultValues","nonScaling","shadowOrGlowType","NONE","Shadow","constructor","arg0","arguments","length","undefined","options","parseShadow","Object","assign","this","ownDefaults","id","uid","value","shadowStr","trim","exec","map","parseFloat","replace","isShadow","STRONG_SHADOW","LIGHT_SHADOW","CUSTOM_SHADOW","isCustomShadow","isGlow","LIGHT_GLOW","STRONG_GLOW","toString","join","toSVG","object","offset","rotateVector","Point","degreesToRadians","angle","Color","fBoxX","fBoxY","width","height","toFixed","Math","abs","x","config","NUM_FRACTION_DIGITS","y","flipX","flipY","toRgb","getAlpha","toObject","data","type","defaults","pickBy","key","fromObject","_defineProperty","classRegistry","setClass"],"mappings":"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"}