import{defineProperty as t}from"../../_virtual/_rollupPluginBabelHelpers.min.mjs";import{radiansToDegrees as r}from"../util/misc/radiansDegreesConversion.min.mjs";import{ColorNameMap as e}from"./color_map.min.mjs";import{reRGBa as s,reHSLa as o,reHex as n}from"./constants.min.mjs";import{rgb2Hsl as i,hexify as c,greyAverage as u,fromAlphaToFloat as a,hue2rgb as l}from"./util.min.mjs";class m{constructor(r){if(t(this,"isUnrecognised",!1),r)if(r instanceof m)this.setSource([...r._source]);else if(Array.isArray(r)){const[t,e,s,o=1]=r;this.setSource([t,e,s,o])}else this.setSource(this._tryParsingColor(r));else this.setSource([0,0,0,1])}_tryParsingColor(t){return(t=t.toLowerCase())in e&&(t=e[t]),"transparent"===t?[255,255,255,0]:m.sourceFromHex(t)||m.sourceFromRgb(t)||m.sourceFromHsl(t)||(this.isUnrecognised=!0)&&[0,0,0,1]}getSource(){return this._source}setSource(t){this._source=t}toRgb(){const[t,r,e]=this.getSource();return`rgb(${t},${r},${e})`}toRgba(){return`rgba(${this.getSource().join(",")})`}toHsl(){const[t,r,e]=i(...this.getSource());return`hsl(${t},${r}%,${e}%)`}toHsla(){const[t,r,e,s]=i(...this.getSource());return`hsla(${t},${r}%,${e}%,${s})`}toHex(){return this.toHexa().slice(0,6)}toHexa(){const[t,r,e,s]=this.getSource();return`${c(t)}${c(r)}${c(e)}${c(Math.round(255*s))}`}getAlpha(){return this.getSource()[3]}setAlpha(t){return this._source[3]=t,this}toGrayscale(){return this.setSource(u(this.getSource())),this}toBlackWhite(t){const[r,,,e]=u(this.getSource()),s=r<(t||127)?0:255;return this.setSource([s,s,s,e]),this}overlayWith(t){t instanceof m||(t=new m(t));const r=this.getSource(),e=t.getSource(),[s,o,n]=r.map(((t,r)=>Math.round(.5*t+.5*e[r])));return this.setSource([s,o,n,r[3]]),this}static fromRgb(t){return m.fromRgba(t)}static fromRgba(t){return new m(m.sourceFromRgb(t))}static sourceFromRgb(t){const r=t.match(s());if(r){const[t,e,s]=r.slice(1,4).map((t=>{const r=parseFloat(t);return t.endsWith("%")?Math.round(2.55*r):r}));return[t,e,s,a(r[4])]}}static fromHsl(t){return m.fromHsla(t)}static fromHsla(t){return new m(m.sourceFromHsl(t))}static sourceFromHsl(t){const r=t.match(o());if(!r)return;const e=(m.parseAngletoDegrees(r[1])%360+360)%360/360,s=parseFloat(r[2])/100,n=parseFloat(r[3])/100;let i,c,u;if(0===s)i=c=u=n;else{const t=n<=.5?n*(s+1):n+s-n*s,r=2*n-t;i=l(r,t,e+1/3),c=l(r,t,e),u=l(r,t,e-1/3)}return[Math.round(255*i),Math.round(255*c),Math.round(255*u),a(r[4])]}static fromHex(t){return new m(m.sourceFromHex(t))}static sourceFromHex(t){if(t.match(n())){const r=t.slice(t.indexOf("#")+1);let e;e=r.length<=4?r.split("").map((t=>t+t)):r.match(/.{2}/g);const[s,o,n,i=255]=e.map((t=>parseInt(t,16)));return[s,o,n,i/255]}}static parseAngletoDegrees(t){const e=t.toLowerCase(),s=parseFloat(e);return e.includes("rad")?r(s):e.includes("turn")?360*s:s}}export{m as Color};
//# sourceMappingURL=Color.min.mjs.map
