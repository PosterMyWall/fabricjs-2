import{applyViewboxTransform as t}from"./applyViewboxTransform.min.mjs";import{svgValidTagNamesRegEx as e}from"./constants.min.mjs";import{hasInvalidAncestor as n}from"./hasInvalidAncestor.min.mjs";import{parseUseDirectives as s}from"./parseUseDirectives.min.mjs";import{ElementsParser as o}from"./elements_parser.min.mjs";import{log as r,SignalAbortedError as m}from"../util/internals/console.min.mjs";import{getTagName as i}from"./getTagName.min.mjs";const l=t=>e.test(i(t)),a=()=>({objects:[],elements:[],options:{},allElements:[]});async function c(e,a){let{crossOrigin:c,signal:p}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(p&&p.aborted)return r("log",new m("parseSVGDocument")),{objects:[],elements:[],options:{},allElements:[]};const f=e.documentElement;s(e);const g=Array.from(f.getElementsByTagName("*")),j={...t(f),crossOrigin:c,signal:p},u=g.filter((e=>(t(e),l(e)&&!n(e))));if(!u||u&&!u.length)return{objects:[],elements:[],options:{},allElements:[],options:j,allElements:g};const b={};g.filter((t=>"clipPath"===i(t))).forEach((t=>{t.setAttribute("originalTransform",t.getAttribute("transform")||"");const e=t.getAttribute("id");b[e]=Array.from(t.getElementsByTagName("*")).filter((t=>l(t)))}));const E=new o(u,j,a,e,b);return{objects:await E.parse(),elements:u,options:j,allElements:g}}export{a as createEmptyResponse,c as parseSVGDocument};
//# sourceMappingURL=parseSVGDocument.min.mjs.map
