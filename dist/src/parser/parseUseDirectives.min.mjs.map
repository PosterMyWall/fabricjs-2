{"version":3,"file":"parseUseDirectives.min.mjs","sources":["../../../src/parser/parseUseDirectives.ts"],"sourcesContent":["import { svgNS } from './constants';\nimport { getMultipleNodes } from './getMultipleNodes';\nimport { applyViewboxTransform } from './applyViewboxTransform';\nimport { parseStyleString } from './parseStyleString';\n\nexport function parseUseDirectives(doc: Document) {\n  const nodelist = getMultipleNodes(doc, ['use', 'svg:use']);\n  const skipAttributes = ['x', 'y', 'xlink:href', 'href', 'transform'];\n\n  for (const useElement of nodelist) {\n    const useAttributes: NamedNodeMap = useElement.attributes;\n\n    const useAttrMap: Record<string, string> = {};\n    for (const attr of useAttributes) {\n      attr.value && (useAttrMap[attr.name] = attr.value);\n    }\n\n    const xlink = (useAttrMap['xlink:href'] || useAttrMap.href || '').slice(1);\n\n    if (xlink === '') {\n      return;\n    }\n    const referencedElement = doc.getElementById(xlink);\n    if (referencedElement === null) {\n      // if we can't find the target of the xlink, consider this use tag bad, similar to no xlink\n      return;\n    }\n    let clonedOriginal = referencedElement.cloneNode(true) as Element;\n\n    const originalAttributes: NamedNodeMap = clonedOriginal.attributes;\n\n    const originalAttrMap: Record<string, string> = {};\n    for (const attr of originalAttributes) {\n      attr.value && (originalAttrMap[attr.name] = attr.value);\n    }\n\n    // Transform attribute needs to be merged in a particular way\n    const { x = 0, y = 0, transform = '' } = useAttrMap;\n    const currentTrans = `${transform} ${\n      originalAttrMap.transform || ''\n    } translate(${x}, ${y})`;\n\n    applyViewboxTransform(clonedOriginal);\n\n    if (/^svg$/i.test(clonedOriginal.nodeName)) {\n      // if is an SVG, create a group and apply all the attributes on top of it\n      const el3 = clonedOriginal.ownerDocument.createElementNS(svgNS, 'g');\n      Object.entries(originalAttrMap).forEach(([name, value]) =>\n        el3.setAttributeNS(svgNS, name, value),\n      );\n      el3.append(...clonedOriginal.childNodes);\n      clonedOriginal = el3;\n    }\n\n    for (const attr of useAttributes) {\n      if (!attr) {\n        continue;\n      }\n      const { name, value } = attr;\n      if (skipAttributes.includes(name)) {\n        continue;\n      }\n\n      if (name === 'style') {\n        // when use has a style, merge the two styles, with the ref being priority (not use)\n        // priority is by feature. an attribute for fill on the original element\n        // will overwrite the fill in style or attribute for tha use\n        const styleRecord: Record<string, any> = {};\n        parseStyleString(value, styleRecord);\n        // cleanup styleRecord from attributes of original\n        Object.entries(originalAttrMap).forEach(([name, value]) => {\n          styleRecord[name] = value;\n        });\n        // now we can put in the style of the original that will overwrite the original attributes\n        parseStyleString(originalAttrMap.style || '', styleRecord);\n        const mergedStyles = Object.entries(styleRecord)\n          .map((entry) => entry.join(':'))\n          .join(';');\n        clonedOriginal.setAttribute(name, mergedStyles);\n      } else {\n        // set the attribute from use element only if the original does not have it already\n        !originalAttrMap[name] && clonedOriginal.setAttribute(name, value);\n      }\n    }\n\n    clonedOriginal.setAttribute('transform', currentTrans);\n    clonedOriginal.setAttribute('instantiated_by_use', '1');\n    clonedOriginal.removeAttribute('id');\n    useElement.parentNode!.replaceChild(clonedOriginal, useElement);\n  }\n}\n"],"names":["parseUseDirectives","doc","nodelist","getMultipleNodes","skipAttributes","useElement","useAttributes","attributes","useAttrMap","attr","value","name","xlink","href","slice","referencedElement","getElementById","clonedOriginal","cloneNode","originalAttributes","originalAttrMap","x","y","transform","currentTrans","applyViewboxTransform","test","nodeName","el3","ownerDocument","createElementNS","svgNS","Object","entries","forEach","_ref","setAttributeNS","append","childNodes","includes","styleRecord","parseStyleString","_ref2","style","mergedStyles","map","entry","join","setAttribute","removeAttribute","parentNode","replaceChild"],"mappings":"gPAKO,SAASA,EAAmBC,GACjC,MAAMC,EAAWC,EAAiBF,EAAK,CAAC,MAAO,YACzCG,EAAiB,CAAC,IAAK,IAAK,aAAc,OAAQ,aAExD,IAAK,MAAMC,KAAcH,EAAU,CACjC,MAAMI,EAA8BD,EAAWE,WAEzCC,EAAqC,CAAE,EAC7C,IAAK,MAAMC,KAAQH,EACjBG,EAAKC,QAAUF,EAAWC,EAAKE,MAAQF,EAAKC,OAG9C,MAAME,GAASJ,EAAW,eAAiBA,EAAWK,MAAQ,IAAIC,MAAM,GAExE,GAAc,KAAVF,EACF,OAEF,MAAMG,EAAoBd,EAAIe,eAAeJ,GAC7C,GAA0B,OAAtBG,EAEF,OAEF,IAAIE,EAAiBF,EAAkBG,WAAU,GAEjD,MAAMC,EAAmCF,EAAeV,WAElDa,EAA0C,CAAE,EAClD,IAAK,MAAMX,KAAQU,EACjBV,EAAKC,QAAUU,EAAgBX,EAAKE,MAAQF,EAAKC,OAInD,MAAMW,EAAEA,EAAI,EAACC,EAAEA,EAAI,EAACC,UAAEA,EAAY,IAAOf,EACnCgB,EAAe,GAAGD,KACtBH,EAAgBG,WAAa,gBACjBF,MAAMC,KAIpB,GAFAG,EAAsBR,GAElB,SAASS,KAAKT,EAAeU,UAAW,CAE1C,MAAMC,EAAMX,EAAeY,cAAcC,gBAAgBC,EAAO,KAChEC,OAAOC,QAAQb,GAAiBc,SAAQC,IAAA,IAAExB,EAAMD,GAAMyB,EAAA,OACpDP,EAAIQ,eAAeL,EAAOpB,EAAMD,EAAM,IAExCkB,EAAIS,UAAUpB,EAAeqB,YAC7BrB,EAAiBW,CACnB,CAEA,IAAK,MAAMnB,KAAQH,EAAe,CAChC,IAAKG,EACH,SAEF,MAAME,KAAEA,EAAID,MAAEA,GAAUD,EACxB,IAAIL,EAAemC,SAAS5B,GAI5B,GAAa,UAATA,EAAkB,CAIpB,MAAM6B,EAAmC,CAAE,EAC3CC,EAAiB/B,EAAO8B,GAExBR,OAAOC,QAAQb,GAAiBc,SAAQQ,IAAmB,IAAjB/B,EAAMD,GAAMgC,EACpDF,EAAY7B,GAAQD,CAAK,IAG3B+B,EAAiBrB,EAAgBuB,OAAS,GAAIH,GAC9C,MAAMI,EAAeZ,OAAOC,QAAQO,GACjCK,KAAKC,GAAUA,EAAMC,KAAK,OAC1BA,KAAK,KACR9B,EAAe+B,aAAarC,EAAMiC,EACpC,MAEGxB,EAAgBT,IAASM,EAAe+B,aAAarC,EAAMD,EAEhE,CAEAO,EAAe+B,aAAa,YAAaxB,GACzCP,EAAe+B,aAAa,sBAAuB,KACnD/B,EAAegC,gBAAgB,MAC/B5C,EAAW6C,WAAYC,aAAalC,EAAgBZ,EACtD,CACF"}