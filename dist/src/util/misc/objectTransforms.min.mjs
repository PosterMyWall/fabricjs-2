import{Point as e}from"../../Point.min.mjs";import{CENTER as s}from"../../constants.min.mjs";import{makeBoundingBoxFromPoints as t}from"./boundingBoxFromPoints.min.mjs";import{qrDecompose as n,multiplyTransformMatrices as i,invertTransform as a}from"./matrix.min.mjs";const l=(e,s)=>{const t=a(s),n=i(t,e.calcOwnMatrix());r(e,n)},o=(e,s)=>r(e,i(s,e.calcOwnMatrix())),r=(t,i)=>{const{translateX:a,translateY:l,scaleX:o,scaleY:r,...c}=n(i),m=new e(a,l);t.flipX=!1,t.flipY=!1,Object.assign(t,c),t.set({scaleX:o,scaleY:r}),t.setPositionByOrigin(m,s,s)},c=e=>{e.scaleX=1,e.scaleY=1,e.skewX=0,e.skewY=0,e.flipX=!1,e.flipY=!1,e.rotate(0)},m=e=>({scaleX:e.scaleX,scaleY:e.scaleY,skewX:e.skewX,skewY:e.skewY,angle:e.angle,left:e.left,flipX:e.flipX,flipY:e.flipY,top:e.top}),p=(s,n,i)=>{const a=s/2,l=n/2,o=[new e(-a,-l),new e(a,-l),new e(-a,l),new e(a,l)].map((e=>e.transform(i))),r=t(o);return new e(r.width,r.height)};export{o as addTransformToObject,r as applyTransformToObject,l as removeTransformFromObject,c as resetObjectTransform,m as saveObjectTransform,p as sizeAfterTransform};
//# sourceMappingURL=objectTransforms.min.mjs.map
