import{defineProperty as t}from"../../_virtual/_rollupPluginBabelHelpers.min.mjs";import{Point as e}from"../Point.min.mjs";import{MODIFIED as r,MOVING as s,RESIZING as o,ROTATING as a,SCALING as i,SKEWING as n,CHANGED as u,MODIFY_POLY as c,MODIFY_PATH as y,iMatrix as l,CENTER as g}from"../constants.min.mjs";import{invertTransform as b}from"../util/misc/matrix.min.mjs";import{resolveOrigin as p}from"../util/misc/resolveOrigin.min.mjs";import{FitContentLayout as h}from"./LayoutStrategies/FitContentLayout.min.mjs";import{LAYOUT_TYPE_OBJECT_MODIFIED as m,LAYOUT_TYPE_OBJECT_MODIFYING as f,LAYOUT_TYPE_INITIALIZATION as j,LAYOUT_TYPE_ADDED as d,LAYOUT_TYPE_REMOVED as L,LAYOUT_TYPE_IMPERATIVE as v}from"./constants.min.mjs";import{classRegistry as x}from"../ClassRegistry.min.mjs";const O="layoutManager";class C{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new h;t(this,"strategy",void 0),this.strategy=e,this._subscriptions=new Map}performLayout(t){const e={bubbles:!0,strategy:this.strategy,...t,prevStrategy:this._prevLayoutStrategy,stopPropagation(){this.bubbles=!1}};this.onBeforeLayout(e);const r=this.getLayoutResult(e);r&&this.commitLayout(e,r),this.onAfterLayout(e,r),this._prevLayoutStrategy=e.strategy}attachHandlers(t,e){const{target:l}=e;return[r,s,o,a,i,n,u,c,y].map((e=>t.on(e,(t=>this.performLayout(e===r?{type:m,trigger:e,e:t,target:l}:{type:f,trigger:e,e:t,target:l})))))}subscribe(t,e){this.unsubscribe(t,e);const r=this.attachHandlers(t,e);this._subscriptions.set(t,r)}unsubscribe(t,e){(this._subscriptions.get(t)||[]).forEach((t=>t())),this._subscriptions.delete(t)}unsubscribeTargets(t){t.targets.forEach((e=>this.unsubscribe(e,t)))}subscribeTargets(t){t.targets.forEach((e=>this.subscribe(e,t)))}onBeforeLayout(t){const{target:e,type:r}=t,{canvas:s}=e;if(r===j||r===d?this.subscribeTargets(t):r===L&&this.unsubscribeTargets(t),e.fire("layout:before",{context:t}),s&&s.fire("object:layout:before",{target:e,context:t}),r===v&&t.deep){const{strategy:r,...s}=t;e.forEachObject((t=>t.layoutManager&&t.layoutManager.performLayout({...s,bubbles:!1,target:t})))}}getLayoutResult(t){const{target:r,strategy:s,type:o}=t,a=s.calcLayoutResult(t,r.getObjects());if(!a)return;const i=o===j?new e:r.getRelativeCenterPoint(),{center:n,correction:u=new e,relativeCorrection:c=new e}=a,y=i.subtract(n).add(u).transform(o===j?l:b(r.calcOwnMatrix()),!0).add(c);return{result:a,prevCenter:i,nextCenter:n,offset:y}}commitLayout(t,e){const{target:r}=t,{result:{size:s},nextCenter:o}=e;var a,i;(r.set({width:s.x,height:s.y}),this.layoutObjects(t,e),t.type===j)?r.set({left:null!==(a=t.x)&&void 0!==a?a:o.x+s.x*p(r.originX),top:null!==(i=t.y)&&void 0!==i?i:o.y+s.y*p(r.originY)}):(r.setPositionByOrigin(o,g,g),r.setCoords(),r.set("dirty",!0))}layoutObjects(t,e){const{target:r}=t;r.forEachObject((s=>{s.group===r&&this.layoutObject(t,e,s)})),t.strategy.shouldLayoutClipPath(t)&&this.layoutObject(t,e,r.clipPath)}layoutObject(t,e,r){let{offset:s}=e;r.set({left:r.left+s.x,top:r.top+s.y})}onAfterLayout(t,e){const{target:r,strategy:s,bubbles:o,prevStrategy:a,...i}=t,{canvas:n}=r;r.fire("layout:after",{context:t,result:e}),n&&n.fire("object:layout:after",{context:t,result:e,target:r});const u=r.parent;o&&null!=u&&u.layoutManager&&((i.path||(i.path=[])).push(r),u.layoutManager.performLayout({...i,target:u})),r.set("dirty",!0)}dispose(){const{_subscriptions:t}=this;t.forEach((t=>t.forEach((t=>t())))),t.clear()}toObject(){return{type:O,strategy:this.strategy.constructor.type}}toJSON(){return this.toObject()}}x.setClass(C,O);export{C as LayoutManager};
//# sourceMappingURL=LayoutManager.min.mjs.map
