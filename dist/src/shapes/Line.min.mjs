import{defineProperty as t}from"../../_virtual/_rollupPluginBabelHelpers.min.mjs";import{SHARED_ATTRIBUTES as i}from"../parser/attributes.min.mjs";import{parseAttributes as s}from"../parser/parseAttributes.min.mjs";import{classRegistry as e}from"../ClassRegistry.min.mjs";import{FabricObject as o}from"./Object/FabricObject.min.mjs";import{Point as r}from"../Point.min.mjs";import{isFiller as n}from"../util/typeAssertions.min.mjs";import{LEFT as m,TOP as h,CENTER as c}from"../constants.min.mjs";import"../util/misc/vectors.min.mjs";import"../util/misc/projectStroke/StrokeLineJoinProjections.min.mjs";import"../config.min.mjs";import"./Group.min.mjs";import{makeBoundingBoxFromPoints as l}from"../util/misc/boundingBoxFromPoints.min.mjs";import"../cache.min.mjs";import"../parser/constants.min.mjs";import"../util/animation/AnimationRegistry.min.mjs";import{cacheProperties as a}from"./Object/defaultValues.min.mjs";const p=["x1","x2","y1","y2"];class y extends o{constructor(){let[t,i,s,e]=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[0,0,0,0],o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};super(),Object.assign(this,y.ownDefaults),this.setOptions(o),this.x1=t,this.x2=s,this.y1=i,this.y2=e,this._setWidthHeight();const{left:r,top:n}=o;"number"==typeof r&&this.set(m,r),"number"==typeof n&&this.set(h,n)}_setWidthHeight(){const{x1:t,y1:i,x2:s,y2:e}=this;this.width=Math.abs(s-t),this.height=Math.abs(e-i);const{left:o,top:n,width:m,height:h}=l([{x:t,y:i},{x:s,y:e}]),a=new r(o+m/2,n+h/2);this.setPositionByOrigin(a,c,c)}_set(t,i){return super._set(t,i),p.includes(t)&&this._setWidthHeight(),this}_render(t){t.beginPath();const i=this.calcLinePoints();t.moveTo(i.x1,i.y1),t.lineTo(i.x2,i.y2),t.lineWidth=this.strokeWidth;const s=t.strokeStyle;var e;n(this.stroke)?t.strokeStyle=this.stroke.toLive(t):t.strokeStyle=null!==(e=this.stroke)&&void 0!==e?e:t.fillStyle;this.stroke&&this._renderStroke(t),t.strokeStyle=s}_findCenterFromElement(){return new r((this.x1+this.x2)/2,(this.y1+this.y2)/2)}toObject(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return{...super.toObject(t),...this.calcLinePoints()}}_getNonTransformedDimensions(){const t=super._getNonTransformedDimensions();return"butt"===this.strokeLineCap&&(0===this.width&&(t.y-=this.strokeWidth),0===this.height&&(t.x-=this.strokeWidth)),t}calcLinePoints(){const{x1:t,x2:i,y1:s,y2:e,width:o,height:r}=this,n=t<=i?-1:1,m=s<=e?-1:1;return{x1:n*o/2,x2:n*-o/2,y1:m*r/2,y2:m*-r/2}}_toSVG(){const{x1:t,x2:i,y1:s,y2:e}=this.calcLinePoints();return["<line ","COMMON_PARTS",`x1="${t}" y1="${s}" x2="${i}" y2="${e}" />\n`]}static async fromElement(t,i,e){const{x1:o=0,y1:r=0,x2:n=0,y2:m=0,...h}=s(t,this.ATTRIBUTE_NAMES,e);return new this([o,r,n,m],h)}static fromObject(t){let{x1:i,y1:s,x2:e,y2:o,...r}=t;return this._fromObject({...r,points:[i,s,e,o]},{extraParam:"points"})}}t(y,"type","Line"),t(y,"cacheProperties",[...a,...p]),t(y,"ATTRIBUTE_NAMES",i.concat(p)),e.setClass(y),e.setSVGClass(y);export{y as Line};
//# sourceMappingURL=Line.min.mjs.map
