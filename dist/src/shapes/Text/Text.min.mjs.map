{"version":3,"file":"Text.min.mjs","sources":["../../../../src/shapes/Text/Text.ts"],"sourcesContent":["import { cache } from '../../cache';\nimport type { NORMAL } from '../../constants';\nimport { DEFAULT_SVG_FONT_SIZE, FILL, LTR, RTL, STROKE } from '../../constants';\nimport type { ObjectEvents } from '../../EventTypeDefs';\nimport type {\n  CompleteTextStyleDeclaration,\n  TextStyle,\n  TextStyleDeclaration,\n} from './StyledText';\nimport { StyledText } from './StyledText';\nimport { SHARED_ATTRIBUTES } from '../../parser/attributes';\nimport { parseAttributes } from '../../parser/parseAttributes';\nimport type {\n  Abortable,\n  TCacheCanvasDimensions,\n  TClassProperties,\n  TFiller,\n  TOptions,\n} from '../../typedefs';\nimport { classRegistry } from '../../ClassRegistry';\nimport { graphemeSplit } from '../../util/lang_string';\nimport { createCanvasElementFor } from '../../util/misc/dom';\nimport type { TextStyleArray } from '../../util/misc/textStyles';\nimport {\n  hasStyleChanged,\n  stylesFromArray,\n  stylesToArray,\n} from '../../util/misc/textStyles';\nimport { getPathSegmentsInfo, getPointOnPath } from '../../util/path';\nimport { cacheProperties } from '../Object/FabricObject';\nimport type { Path } from '../Path';\nimport { TextSVGExportMixin } from './TextSVGExportMixin';\nimport { applyMixins } from '../../util/applyMixins';\nimport type { FabricObjectProps, SerializedObjectProps } from '../Object/types';\nimport type { StylePropertiesType } from './constants';\nimport {\n  additionalProps,\n  textDefaultValues,\n  textLayoutProperties,\n  JUSTIFY,\n  JUSTIFY_CENTER,\n  JUSTIFY_LEFT,\n  JUSTIFY_RIGHT,\n  TEXT_DECORATION_THICKNESS,\n} from './constants';\nimport { CENTER, LEFT, RIGHT, TOP, BOTTOM } from '../../constants';\nimport { isFiller } from '../../util/typeAssertions';\nimport type { Gradient } from '../../gradient/Gradient';\nimport type { Pattern } from '../../Pattern';\nimport type { CSSRules } from '../../parser/typedefs';\nimport { normalizeWs } from '../../util/internals/normalizeWhiteSpace';\n\nlet measuringContext: CanvasRenderingContext2D | null;\n\n/**\n * Return a context for measurement of text string.\n * if created it gets stored for reuse\n */\nfunction getMeasuringContext() {\n  if (!measuringContext) {\n    const canvas = createCanvasElementFor({\n      width: 0,\n      height: 0,\n    });\n    measuringContext = canvas.getContext('2d');\n  }\n  return measuringContext;\n}\n\nexport type TPathSide = 'left' | 'right';\n\nexport type TPathAlign = 'baseline' | 'center' | 'ascender' | 'descender';\n\nexport type TextLinesInfo = {\n  lines: string[];\n  graphemeLines: string[][];\n  graphemeText: string[];\n  _unwrappedLines: string[][];\n};\n\nexport type TextAlign =\n  | typeof LEFT\n  | typeof CENTER\n  | typeof RIGHT\n  | typeof JUSTIFY\n  | typeof JUSTIFY_LEFT\n  | typeof JUSTIFY_CENTER\n  | typeof JUSTIFY_RIGHT;\n\nexport type FontStyle = '' | typeof NORMAL | 'italic' | 'oblique';\n\n/**\n * Measure and return the info of a single grapheme.\n * needs the the info of previous graphemes already filled\n * Override to customize measuring\n */\nexport type GraphemeBBox = {\n  width: number;\n  height: number;\n  kernedWidth: number;\n  left: number;\n  deltaY: number;\n  renderLeft?: number;\n  renderTop?: number;\n  angle?: number;\n};\n\n// @TODO this is not complete\ninterface UniqueTextProps {\n  charSpacing: number;\n  lineHeight: number;\n  fontSize: number;\n  cacheExpansionFactor: number;\n  fontWeight: string | number;\n  fontFamily: string;\n  fontStyle: FontStyle;\n  pathSide: TPathSide;\n  pathAlign: TPathAlign;\n  underline: boolean;\n  overline: boolean;\n  linethrough: boolean;\n  textAlign: TextAlign;\n  squigglyline: boolean;\n  ignoreDelegatedSet: boolean;\n  squigglylineColor: string;\n  isStrokeForBold: boolean;\n  direction: CanvasDirection;\n  path?: Path;\n  textDecorationThickness: number;\n}\n\nexport interface SerializedTextProps\n  extends SerializedObjectProps,\n    UniqueTextProps {\n  styles: TextStyleArray | TextStyle;\n}\n\nexport interface TextProps extends FabricObjectProps, UniqueTextProps {\n  styles: TextStyle;\n}\n\n/**\n * Text class\n * @see {@link http://fabric5.fabricjs.com/fabric-intro-part-2#text}\n */\nexport class FabricText<\n    Props extends TOptions<TextProps> = Partial<TextProps>,\n    SProps extends SerializedTextProps = SerializedTextProps,\n    EventSpec extends ObjectEvents = ObjectEvents,\n  >\n  extends StyledText<Props, SProps, EventSpec>\n  implements UniqueTextProps\n{\n  /**\n   * Properties that requires a text layout recalculation when changed\n   * @type string[]\n   * @protected\n   */\n  static textLayoutProperties: string[] = textLayoutProperties;\n\n  /**\n   * @private\n   */\n  declare _reNewline: RegExp;\n\n  /**\n   * Use this regular expression to filter for whitespaces that is not a new line.\n   * Mostly used when text is 'justify' aligned.\n   * @private\n   */\n  declare _reSpacesAndTabs: RegExp;\n\n  /**\n   * Use this regular expression to filter for whitespace that is not a new line.\n   * Mostly used when text is 'justify' aligned.\n   * @private\n   */\n  declare _reSpaceAndTab: RegExp;\n\n  /**\n   * Use this regular expression to filter consecutive groups of non spaces.\n   * Mostly used when text is 'justify' aligned.\n   * @private\n   */\n  declare _reWords: RegExp;\n\n  declare text: string;\n\n  /**\n   * Font size (in pixels)\n   * @type Number\n   */\n  declare fontSize: number;\n\n  /**\n   * *PMW*\n   * Property added to expand text cache canvas more than default expansion for fonts which get cut off.\n   */\n  declare cacheExpansionFactor: number;\n\n  /**\n   * Font weight (e.g. bold, normal, 400, 600, 800)\n   * @type {(Number|String)}\n   */\n  declare fontWeight: string | number;\n\n  /**\n   * Font family\n   * @type String\n   */\n  declare fontFamily: string;\n\n  /**\n   * Text decoration underline.\n   * @type Boolean\n   */\n  declare underline: boolean;\n\n  /**\n   * Text decoration overline.\n   * @type Boolean\n   */\n  declare overline: boolean;\n\n  /**\n   * Text decoration linethrough.\n   * @type Boolean\n   */\n  declare linethrough: boolean;\n\n  /*PMW*/\n  declare squigglyline: boolean;\n  /*PMW*/\n  declare squigglylineColor: string;\n  declare isStrokeForBold: boolean;\n\n  //*PMW*\n  /******These are just custom properties later used by our webapp code. They are added here for ts support*************/\n  declare ignoreDelegatedSet: boolean;\n\n  /**\n   * Text alignment. Possible values: \"left\", \"center\", \"right\", \"justify\",\n   * \"justify-left\", \"justify-center\" or \"justify-right\".\n   * @type TextAlign\n   */\n  declare textAlign: TextAlign;\n\n  /**\n   * Font style . Possible values: \"\", \"normal\", \"italic\" or \"oblique\".\n   * @type FontStyle\n   */\n  declare fontStyle: FontStyle;\n\n  /**\n   * Line height\n   * @type Number\n   */\n  declare lineHeight: number;\n\n  /**\n   * Superscript schema object (minimum overlap)\n   */\n  declare superscript: {\n    /**\n     * fontSize factor\n     * @default 0.6\n     */\n    size: number;\n    /**\n     * baseline-shift factor (upwards)\n     * @default -0.35\n     */\n    baseline: number;\n  };\n\n  /**\n   * Subscript schema object (minimum overlap)\n   */\n  declare subscript: {\n    /**\n     * fontSize factor\n     * @default 0.6\n     */\n    size: number;\n    /**\n     * baseline-shift factor (downwards)\n     * @default 0.11\n     */\n    baseline: number;\n  };\n\n  /**\n   * Background color of text lines\n   * @type String\n   */\n  declare textBackgroundColor: string;\n\n  declare styles: TextStyle;\n\n  /**\n   * Path that the text should follow.\n   * since 4.6.0 the path will be drawn automatically.\n   * if you want to make the path visible, give it a stroke and strokeWidth or fill value\n   * if you want it to be hidden, assign visible = false to the path.\n   * This feature is in BETA, and SVG import/export is not yet supported.\n   * @type Path\n   * @example\n   * const textPath = new Text('Text on a path', {\n   *     top: 150,\n   *     left: 150,\n   *     textAlign: 'center',\n   *     charSpacing: -50,\n   *     path: new Path('M 0 0 C 50 -100 150 -100 200 0', {\n   *         strokeWidth: 1,\n   *         visible: false\n   *     }),\n   *     pathSide: 'left',\n   *     pathStartOffset: 0\n   * });\n   */\n  declare path?: Path;\n\n  /**\n   * The text decoration tickness for underline, overline and strikethrough\n   * The tickness is expressed in thousandths of fontSize ( em ).\n   * The original value was 1/15 that translates to 66.6667 thousandths.\n   * The choice of unit of measure is to align with charSpacing.\n   * You can slim the tickness without issues, while large underline or overline may end up\n   * outside the bounding box of the text. In order to fix that a bigger refactor of the code\n   * is needed and is out of scope for now. If you need such large overline on the first line\n   * of text or large underline on the last line of text, consider disabling caching as a\n   * workaround\n   * @default 66.667\n   */\n  declare textDecorationThickness: number;\n\n  /**\n   * Offset amount for text path starting position\n   * Only used when text has a path\n   */\n  declare pathStartOffset: number;\n\n  /**\n   * Which side of the path the text should be drawn on.\n   * Only used when text has a path\n   * @type {TPathSide} 'left|right'\n   */\n  declare pathSide: TPathSide;\n\n  /**\n   * How text is aligned to the path. This property determines\n   * the perpendicular position of each character relative to the path.\n   * (one of \"baseline\", \"center\", \"ascender\", \"descender\")\n   * This feature is in BETA, and its behavior may change\n   * @type TPathAlign\n   */\n  declare pathAlign: TPathAlign;\n\n  /**\n   * @private\n   */\n  declare _fontSizeFraction: number;\n\n  /**\n   * @private\n   */\n  declare offsets: {\n    underline: number;\n    linethrough: number;\n    squigglyline: number;\n    overline: number;\n  };\n\n  /**\n   * Text Line proportion to font Size (in pixels)\n   * @type Number\n   */\n  declare _fontSizeMult: number;\n\n  /**\n   * additional space between characters\n   * expressed in thousands of em unit\n   * @type Number\n   */\n  declare charSpacing: number;\n\n  /**\n   * Baseline shift, styles only, keep at 0 for the main text object\n   * @type {Number}\n   */\n  declare deltaY: number;\n\n  /**\n   * WARNING: EXPERIMENTAL. NOT SUPPORTED YET\n   * determine the direction of the text.\n   * This has to be set manually together with textAlign and originX for proper\n   * experience.\n   * some interesting link for the future\n   * https://www.w3.org/International/questions/qa-bidi-unicode-controls\n   * @since 4.5.0\n   * @type {CanvasDirection} 'ltr|rtl'\n   */\n  declare direction: CanvasDirection;\n\n  /**\n   * contains characters bounding boxes\n   * This variable is considered to be protected.\n   * But for how mixins are implemented right now, we can't leave it private\n   * @protected\n   */\n  __charBounds: GraphemeBBox[][] = [];\n\n  /**\n   * use this size when measuring text. To avoid IE11 rounding errors\n   * @type {Number}\n   * @readonly\n   * @private\n   */\n  declare CACHE_FONT_SIZE: number;\n\n  /**\n   * contains the min text width to avoid getting 0\n   * @type {Number}\n   */\n  declare MIN_TEXT_WIDTH: number;\n\n  /**\n   * contains the the text of the object, divided in lines as they are displayed\n   * on screen. Wrapping will divide the text independently of line breaks\n   * @type {string[]}\n   */\n  declare textLines: string[];\n\n  /**\n   * same as textlines, but each line is an array of graphemes as split by splitByGrapheme\n   * @type {string[]}\n   */\n  declare _textLines: string[][];\n\n  declare _unwrappedTextLines: string[][];\n  declare _text: string[];\n  declare cursorWidth: number;\n  declare __lineHeights: number[];\n  declare __lineWidths: number[];\n  declare initialized?: true;\n\n  static cacheProperties = [...cacheProperties, ...additionalProps];\n\n  static ownDefaults = textDefaultValues;\n\n  static type = 'Text';\n\n  static getDefaults(): Record<string, any> {\n    return { ...super.getDefaults(), ...FabricText.ownDefaults };\n  }\n\n  constructor(text: string, options?: Props) {\n    super();\n    Object.assign(this, FabricText.ownDefaults);\n    this.setOptions(options);\n    if (!this.styles) {\n      this.styles = {};\n    }\n    this.text = text;\n    this.initialized = true;\n    if (this.path) {\n      this.setPathInfo();\n    }\n    this.initDimensions();\n    this.setCoords();\n  }\n\n  /**\n   * If text has a path, it will add the extra information needed\n   * for path and text calculations\n   */\n  setPathInfo() {\n    const path = this.path;\n    if (path) {\n      path.segmentsInfo = getPathSegmentsInfo(path.path);\n    }\n  }\n\n  /**\n   * @private\n   * Divides text into lines of text and lines of graphemes.\n   */\n  _splitText(): TextLinesInfo {\n    const newLines = this._splitTextIntoLines(this.text);\n    this.textLines = newLines.lines;\n    this._textLines = newLines.graphemeLines;\n    this._unwrappedTextLines = newLines._unwrappedLines;\n    this._text = newLines.graphemeText;\n    return newLines;\n  }\n\n  /**\n   * Initialize or update text dimensions.\n   * Updates this.width and this.height with the proper values.\n   * Does not return dimensions.\n   */\n  initDimensions() {\n    this._splitText();\n    this._clearCache();\n    this.dirty = true;\n    if (this.path) {\n      this.width = this.path.width;\n      this.height = this.path.height;\n    } else {\n      this.width =\n        this.calcTextWidth() || this.cursorWidth || this.MIN_TEXT_WIDTH;\n      this.height = this.calcTextHeight();\n    }\n    if (this.textAlign.includes(JUSTIFY)) {\n      // once text is measured we need to make space fatter to make justified text.\n      this.enlargeSpaces();\n    }\n  }\n\n  /**\n   * Enlarge space boxes and shift the others\n   */\n  enlargeSpaces() {\n    let diffSpace,\n      currentLineWidth,\n      numberOfSpaces,\n      accumulatedSpace,\n      line,\n      charBound,\n      spaces;\n    for (let i = 0, len = this._textLines.length; i < len; i++) {\n      if (\n        this.textAlign !== JUSTIFY &&\n        (i === len - 1 || this.isEndOfWrapping(i))\n      ) {\n        continue;\n      }\n      accumulatedSpace = 0;\n      line = this._textLines[i];\n      currentLineWidth = this.getLineWidth(i);\n      if (\n        currentLineWidth < this.width &&\n        (spaces = this.textLines[i].match(this._reSpacesAndTabs))\n      ) {\n        numberOfSpaces = spaces.length;\n        diffSpace = (this.width - currentLineWidth) / numberOfSpaces;\n        for (let j = 0; j <= line.length; j++) {\n          charBound = this.__charBounds[i][j];\n          if (this._reSpaceAndTab.test(line[j])) {\n            charBound.width += diffSpace;\n            charBound.kernedWidth += diffSpace;\n            charBound.left += accumulatedSpace;\n            accumulatedSpace += diffSpace;\n          } else {\n            charBound.left += accumulatedSpace;\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Detect if the text line is ended with an hard break\n   * text and itext do not have wrapping, return false\n   * @return {Boolean}\n   */\n  isEndOfWrapping(lineIndex: number): boolean {\n    return lineIndex === this._textLines.length - 1;\n  }\n\n  /**\n   * Detect if a line has a linebreak and so we need to account for it when moving\n   * and counting style.\n   * It return always 1 for text and Itext. Textbox has its own implementation\n   * @return Number\n   */\n  missingNewlineOffset(lineIndex: number, skipWrapping?: boolean): 0 | 1;\n  missingNewlineOffset(_lineIndex: number): 1 {\n    return 1;\n  }\n\n  /**\n   * Returns 2d representation (lineIndex and charIndex) of cursor\n   * @param {Number} selectionStart\n   * @param {Boolean} [skipWrapping] consider the location for unwrapped lines. useful to manage styles.\n   */\n  get2DCursorLocation(selectionStart: number, skipWrapping?: boolean) {\n    const lines = skipWrapping ? this._unwrappedTextLines : this._textLines;\n    let i: number;\n    for (i = 0; i < lines.length; i++) {\n      if (selectionStart <= lines[i].length) {\n        return {\n          lineIndex: i,\n          charIndex: selectionStart,\n        };\n      }\n      selectionStart -=\n        lines[i].length + this.missingNewlineOffset(i, skipWrapping);\n    }\n    return {\n      lineIndex: i - 1,\n      charIndex:\n        lines[i - 1].length < selectionStart\n          ? lines[i - 1].length\n          : selectionStart,\n    };\n  }\n\n  /**\n   * Returns string representation of an instance\n   * @return {String} String representation of text object\n   */\n  toString(): string {\n    return `#<Text (${this.complexity()}): { \"text\": \"${\n      this.text\n    }\", \"fontFamily\": \"${this.fontFamily}\" }>`;\n  }\n\n  /**\n   * Return the dimension and the zoom level needed to create a cache canvas\n   * big enough to host the object to be cached.\n   * @private\n   * @param {Object} dim.x width of object to be cached\n   * @param {Object} dim.y height of object to be cached\n   * @return {Object}.width width of canvas\n   * @return {Object}.height height of canvas\n   * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache\n   * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache\n   */\n  _getCacheCanvasDimensions(): TCacheCanvasDimensions {\n    const dims = super._getCacheCanvasDimensions();\n    const fontSize = this.fontSize;\n    dims.width += fontSize * dims.zoomX;\n    dims.height += fontSize * dims.zoomY * this.cacheExpansionFactor;\n    return dims;\n  }\n\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} ctx Context to render on\n   */\n  _render(ctx: CanvasRenderingContext2D) {\n    const path = this.path;\n    path && !path.isNotVisible() && path._render(ctx);\n    this._setTextStyles(ctx);\n    this._renderTextLinesBackground(ctx);\n    this._renderTextDecoration(ctx, 'underline');\n    this._renderText(ctx);\n    this._renderTextDecoration(ctx, 'overline');\n    this._renderTextDecoration(ctx, 'linethrough');\n    this._renderTextDecoration(ctx, 'squigglyline'); // *PMW*\n  }\n\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} ctx Context to render on\n   */\n  _renderText(ctx: CanvasRenderingContext2D) {\n    if (this.paintFirst === STROKE) {\n      this._renderTextStroke(ctx);\n      this._renderTextFill(ctx);\n    } else {\n      this._renderTextFill(ctx);\n      this._renderTextStroke(ctx);\n    }\n  }\n\n  /**\n   * Set the font parameter of the context with the object properties or with charStyle\n   * @private\n   * @param {CanvasRenderingContext2D} ctx Context to render on\n   * @param {Object} [charStyle] object with font style properties\n   * @param {String} [charStyle.fontFamily] Font Family\n   * @param {Number} [charStyle.fontSize] Font size in pixels. ( without px suffix )\n   * @param {String} [charStyle.fontWeight] Font weight\n   * @param {String} [charStyle.fontStyle] Font style (italic|normal)\n   */\n  _setTextStyles(\n    ctx: CanvasRenderingContext2D,\n    charStyle?: any,\n    forMeasuring?: boolean,\n  ) {\n    ctx.textBaseline = 'alphabetic';\n    if (this.path) {\n      switch (this.pathAlign) {\n        case CENTER:\n          ctx.textBaseline = 'middle';\n          break;\n        case 'ascender':\n          ctx.textBaseline = TOP;\n          break;\n        case 'descender':\n          ctx.textBaseline = BOTTOM;\n          break;\n      }\n    }\n    ctx.font = this._getFontDeclaration(charStyle, forMeasuring);\n  }\n\n  /**\n   * calculate and return the text Width measuring each line.\n   * @private\n   * @param {CanvasRenderingContext2D} ctx Context to render on\n   * @return {Number} Maximum width of Text object\n   */\n  calcTextWidth(): number {\n    let maxWidth = this.getLineWidth(0);\n\n    for (let i = 1, len = this._textLines.length; i < len; i++) {\n      const currentLineWidth = this.getLineWidth(i);\n      if (currentLineWidth > maxWidth) {\n        maxWidth = currentLineWidth;\n      }\n    }\n    return maxWidth;\n  }\n\n  /**\n   * @private\n   * @param {String} method Method name (\"fillText\" or \"strokeText\")\n   * @param {CanvasRenderingContext2D} ctx Context to render on\n   * @param {String} line Text to render\n   * @param {Number} left Left position of text\n   * @param {Number} top Top position of text\n   * @param {Number} lineIndex Index of a line in a text\n   */\n  _renderTextLine(\n    method: 'fillText' | 'strokeText',\n    ctx: CanvasRenderingContext2D,\n    line: string[],\n    left: number,\n    top: number,\n    lineIndex: number,\n  ) {\n    this._renderChars(method, ctx, line, left, top, lineIndex);\n  }\n\n  /**\n   * Renders the text background for lines, taking care of style\n   * @private\n   * @param {CanvasRenderingContext2D} ctx Context to render on\n   */\n  _renderTextLinesBackground(ctx: CanvasRenderingContext2D) {\n    if (!this.textBackgroundColor && !this.styleHas('textBackgroundColor')) {\n      return;\n    }\n    const originalFill = ctx.fillStyle,\n      leftOffset = this._getLeftOffset();\n    let lineTopOffset = this._getTopOffset();\n\n    for (let i = 0, len = this._textLines.length; i < len; i++) {\n      const heightOfLine = this.getHeightOfLine(i);\n      if (\n        !this.textBackgroundColor &&\n        !this.styleHas('textBackgroundColor', i)\n      ) {\n        lineTopOffset += heightOfLine;\n        continue;\n      }\n      const jlen = this._textLines[i].length;\n      const lineLeftOffset = this._getLineLeftOffset(i);\n      let boxWidth = 0;\n      let boxStart = 0;\n      let drawStart;\n      let currentColor;\n      let lastColor = this.getValueOfPropertyAt(i, 0, 'textBackgroundColor');\n      const bgHeight = this.getHeightOfLineImpl(i);\n      for (let j = 0; j < jlen; j++) {\n        // at this point charbox are either standard or full with pathInfo if there is a path.\n        const charBox = this.__charBounds[i][j] as Required<GraphemeBBox>;\n        currentColor = this.getValueOfPropertyAt(i, j, 'textBackgroundColor');\n        if (this.path) {\n          ctx.save();\n          ctx.translate(charBox.renderLeft, charBox.renderTop);\n          ctx.rotate(charBox.angle);\n          ctx.fillStyle = currentColor;\n          currentColor &&\n            ctx.fillRect(\n              -charBox.width / 2,\n              -bgHeight * (1 - this._fontSizeFraction),\n              charBox.width,\n              bgHeight,\n            );\n          ctx.restore();\n        } else if (currentColor !== lastColor) {\n          drawStart = leftOffset + lineLeftOffset + boxStart;\n          if (this.direction === RTL) {\n            drawStart = this.width - drawStart - boxWidth;\n          }\n          ctx.fillStyle = lastColor;\n          lastColor &&\n            ctx.fillRect(drawStart, lineTopOffset, boxWidth, bgHeight);\n          boxStart = charBox.left;\n          boxWidth = charBox.width;\n          lastColor = currentColor;\n        } else {\n          boxWidth += charBox.kernedWidth;\n        }\n      }\n      if (currentColor && !this.path) {\n        drawStart = leftOffset + lineLeftOffset + boxStart;\n        if (this.direction === RTL) {\n          drawStart = this.width - drawStart - boxWidth;\n        }\n        ctx.fillStyle = currentColor;\n        ctx.fillRect(drawStart, lineTopOffset, boxWidth, bgHeight);\n      }\n      lineTopOffset += heightOfLine;\n    }\n    ctx.fillStyle = originalFill;\n    // if there is text background color no\n    // other shadows should be casted\n    this._removeShadow(ctx);\n  }\n\n  /**\n   * measure and return the width of a single character.\n   * possibly overridden to accommodate different measure logic or\n   * to hook some external lib for character measurement\n   * @private\n   * @param {String} _char, char to be measured\n   * @param {Object} charStyle style of char to be measured\n   * @param {String} [previousChar] previous char\n   * @param {Object} [prevCharStyle] style of previous char\n   */\n  _measureChar(\n    _char: string,\n    charStyle: CompleteTextStyleDeclaration,\n    previousChar: string | undefined,\n    prevCharStyle: CompleteTextStyleDeclaration | Record<string, never>,\n  ) {\n    const fontCache = cache.getFontCache(charStyle),\n      fontDeclaration = this._getFontDeclaration(charStyle),\n      couple = previousChar ? previousChar + _char : _char,\n      stylesAreEqual =\n        previousChar &&\n        fontDeclaration === this._getFontDeclaration(prevCharStyle),\n      fontMultiplier = charStyle.fontSize / this.CACHE_FONT_SIZE;\n    let width: number | undefined,\n      coupleWidth: number | undefined,\n      previousWidth: number | undefined,\n      kernedWidth: number | undefined;\n\n    if (previousChar && fontCache.has(previousChar)) {\n      previousWidth = fontCache.get(previousChar);\n    }\n    if (fontCache.has(_char)) {\n      kernedWidth = width = fontCache.get(_char);\n    }\n    if (stylesAreEqual && fontCache.has(couple)) {\n      coupleWidth = fontCache.get(couple)!;\n      kernedWidth = coupleWidth - previousWidth!;\n    }\n    if (\n      width === undefined ||\n      previousWidth === undefined ||\n      coupleWidth === undefined\n    ) {\n      const ctx = getMeasuringContext()!;\n      // send a TRUE to specify measuring font size CACHE_FONT_SIZE\n      this._setTextStyles(ctx, charStyle, true);\n      if (width === undefined) {\n        kernedWidth = width = ctx.measureText(_char).width;\n        fontCache.set(_char, width);\n      }\n      if (previousWidth === undefined && stylesAreEqual && previousChar) {\n        previousWidth = ctx.measureText(previousChar).width;\n        fontCache.set(previousChar, previousWidth);\n      }\n      if (stylesAreEqual && coupleWidth === undefined) {\n        // we can measure the kerning couple and subtract the width of the previous character\n        coupleWidth = ctx.measureText(couple).width;\n        fontCache.set(couple, coupleWidth);\n        // safe to use the non-null since if undefined we defined it before.\n        kernedWidth = coupleWidth - previousWidth!;\n      }\n    }\n    return {\n      width: width * fontMultiplier,\n      kernedWidth: kernedWidth! * fontMultiplier,\n    };\n  }\n\n  /**\n   * Computes height of character at given position\n   * @param {Number} line the line index number\n   * @param {Number} _char the character index number\n   * @return {Number} fontSize of the character\n   */\n  getHeightOfChar(line: number, _char: number): number {\n    return this.getValueOfPropertyAt(line, _char, 'fontSize');\n  }\n\n  /**\n   * measure a text line measuring all characters.\n   * @param {Number} lineIndex line number\n   */\n  measureLine(lineIndex: number) {\n    const lineInfo = this._measureLine(lineIndex);\n    if (this.charSpacing !== 0) {\n      lineInfo.width -= this._getWidthOfCharSpacing();\n    }\n    if (lineInfo.width < 0) {\n      lineInfo.width = 0;\n    }\n    return lineInfo;\n  }\n\n  /**\n   * measure every grapheme of a line, populating __charBounds\n   * @param {Number} lineIndex\n   * @return {Object} object.width total width of characters\n   * @return {Object} object.numOfSpaces length of chars that match this._reSpacesAndTabs\n   */\n  _measureLine(lineIndex: number) {\n    let width = 0,\n      prevGrapheme: string | undefined,\n      graphemeInfo: GraphemeBBox | undefined;\n\n    const reverse = this.pathSide === RIGHT,\n      path = this.path,\n      line = this._textLines[lineIndex],\n      llength = line.length,\n      lineBounds = new Array<GraphemeBBox>(llength);\n\n    this.__charBounds[lineIndex] = lineBounds;\n    for (let i = 0; i < llength; i++) {\n      const grapheme = line[i];\n      graphemeInfo = this._getGraphemeBox(grapheme, lineIndex, i, prevGrapheme);\n      lineBounds[i] = graphemeInfo;\n      width += graphemeInfo.kernedWidth;\n      prevGrapheme = grapheme;\n    }\n    // this latest bound box represent the last character of the line\n    // to simplify cursor handling in interactive mode.\n    lineBounds[llength] = {\n      left: graphemeInfo ? graphemeInfo.left + graphemeInfo.width : 0,\n      width: 0,\n      kernedWidth: 0,\n      height: this.fontSize,\n      deltaY: 0,\n    } as GraphemeBBox;\n    if (path && path.segmentsInfo) {\n      let positionInPath = 0;\n      const totalPathLength =\n        path.segmentsInfo[path.segmentsInfo.length - 1].length;\n      switch (this.textAlign) {\n        case LEFT:\n          positionInPath = reverse ? totalPathLength - width : 0;\n          break;\n        case CENTER:\n          positionInPath = (totalPathLength - width) / 2;\n          break;\n        case RIGHT:\n          positionInPath = reverse ? 0 : totalPathLength - width;\n          break;\n        //todo - add support for justify\n      }\n      positionInPath += this.pathStartOffset * (reverse ? -1 : 1);\n      for (\n        let i = reverse ? llength - 1 : 0;\n        reverse ? i >= 0 : i < llength;\n        reverse ? i-- : i++\n      ) {\n        graphemeInfo = lineBounds[i];\n        if (positionInPath > totalPathLength) {\n          positionInPath %= totalPathLength;\n        } else if (positionInPath < 0) {\n          positionInPath += totalPathLength;\n        }\n        // it would probably much faster to send all the grapheme position for a line\n        // and calculate path position/angle at once.\n        this._setGraphemeOnPath(positionInPath, graphemeInfo);\n        positionInPath += graphemeInfo.kernedWidth;\n      }\n    }\n    return { width: width, numOfSpaces: 0 };\n  }\n\n  /**\n   * Calculate the angle  and the left,top position of the char that follow a path.\n   * It appends it to graphemeInfo to be reused later at rendering\n   * @private\n   * @param {Number} positionInPath to be measured\n   * @param {GraphemeBBox} graphemeInfo current grapheme box information\n   * @param {Object} startingPoint position of the point\n   */\n  _setGraphemeOnPath(positionInPath: number, graphemeInfo: GraphemeBBox) {\n    const centerPosition = positionInPath + graphemeInfo.kernedWidth / 2,\n      path = this.path!;\n\n    // we are at currentPositionOnPath. we want to know what point on the path is.\n    const info = getPointOnPath(path.path, centerPosition, path.segmentsInfo)!;\n    graphemeInfo.renderLeft = info.x - path.pathOffset.x;\n    graphemeInfo.renderTop = info.y - path.pathOffset.y;\n    graphemeInfo.angle = info.angle + (this.pathSide === RIGHT ? Math.PI : 0);\n  }\n\n  /**\n   *\n   * @param {String} grapheme to be measured\n   * @param {Number} lineIndex index of the line where the char is\n   * @param {Number} charIndex position in the line\n   * @param {String} [prevGrapheme] character preceding the one to be measured\n   * @returns {GraphemeBBox} grapheme bbox\n   */\n  _getGraphemeBox(\n    grapheme: string,\n    lineIndex: number,\n    charIndex: number,\n    prevGrapheme?: string,\n    skipLeft?: boolean,\n  ): GraphemeBBox {\n    const style = this.getCompleteStyleDeclaration(lineIndex, charIndex),\n      prevStyle = prevGrapheme\n        ? this.getCompleteStyleDeclaration(lineIndex, charIndex - 1)\n        : {},\n      info = this._measureChar(grapheme, style, prevGrapheme, prevStyle);\n    let kernedWidth = info.kernedWidth,\n      width = info.width,\n      charSpacing;\n\n    if (this.charSpacing !== 0) {\n      charSpacing = this._getWidthOfCharSpacing();\n      width += charSpacing;\n      kernedWidth += charSpacing;\n    }\n\n    const box: GraphemeBBox = {\n      width,\n      left: 0,\n      height: style.fontSize,\n      kernedWidth,\n      deltaY: style.deltaY,\n    };\n    if (charIndex > 0 && !skipLeft) {\n      const previousBox = this.__charBounds[lineIndex][charIndex - 1];\n      box.left =\n        previousBox.left + previousBox.width + info.kernedWidth - info.width;\n    }\n    return box;\n  }\n\n  /**\n   * Calculate height of line at 'lineIndex',\n   * without the lineHeigth multiplication factor\n   * @private\n   * @param {Number} lineIndex index of line to calculate\n   * @return {Number}\n   */\n  private getHeightOfLineImpl(lineIndex: number): number {\n    const lh = this.__lineHeights;\n    if (lh[lineIndex]) {\n      return lh[lineIndex];\n    }\n\n    // char 0 is measured before the line cycle because it needs to char\n    // emptylines\n    let maxHeight = this.getHeightOfChar(lineIndex, 0);\n    for (let i = 1, len = this._textLines[lineIndex].length; i < len; i++) {\n      maxHeight = Math.max(this.getHeightOfChar(lineIndex, i), maxHeight);\n    }\n\n    return (lh[lineIndex] = maxHeight * this._fontSizeMult);\n  }\n\n  /**\n   * Calculate height of line at 'lineIndex'\n   * @param {Number} lineIndex index of line to calculate\n   * @return {Number}\n   */\n  getHeightOfLine(lineIndex: number): number {\n    return this.getHeightOfLineImpl(lineIndex) * this.lineHeight;\n  }\n\n  /**\n   * Calculate text box height\n   */\n  calcTextHeight() {\n    let lineHeight,\n      height = 0;\n    for (let i = 0, len = this._textLines.length; i < len; i++) {\n      // //*PMW* commenting out the code that prevent text box from applying line height on the last line. This caused line height to not work in table and menus\n      // height +=\n      //   i === len - 1 ? this.getHeightOfLineImpl(i) : this.getHeightOfLine(i);\n\n      // *PMW* preventing height to be smaller than selector size.\n      lineHeight = this.getHeightOfLine(i);\n      height +=\n        i === len - 1 && this.lineHeight < 1\n          ? lineHeight / this.lineHeight\n          : lineHeight;\n\n    }\n    return height;\n  }\n\n  /**\n   * @private\n   * @return {Number} Left offset\n   */\n  _getLeftOffset(): number {\n    return this.direction === LTR ? -this.width / 2 : this.width / 2;\n  }\n\n  /**\n   * @private\n   * @return {Number} Top offset\n   */\n  _getTopOffset(): number {\n    return -this.height / 2;\n  }\n\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} ctx Context to render on\n   * @param {String} method Method name (\"fillText\" or \"strokeText\")\n   */\n  _renderTextCommon(\n    ctx: CanvasRenderingContext2D,\n    method: 'fillText' | 'strokeText',\n  ) {\n    ctx.save();\n    let lineHeights = 0;\n    const left = this._getLeftOffset(),\n      top = this._getTopOffset();\n    for (let i = 0, len = this._textLines.length; i < len; i++) {\n      this._renderTextLine(\n        method,\n        ctx,\n        this._textLines[i],\n        left + this._getLineLeftOffset(i),\n        top + lineHeights + this.getHeightOfLineImpl(i),\n        i,\n      );\n      lineHeights += this.getHeightOfLine(i);\n    }\n    ctx.restore();\n  }\n\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} ctx Context to render on\n   */\n  _renderTextFill(ctx: CanvasRenderingContext2D) {\n    if (!this.fill && !this.styleHas(FILL)) {\n      return;\n    }\n\n    this._renderTextCommon(ctx, 'fillText');\n  }\n\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} ctx Context to render on\n   */\n  _renderTextStroke(ctx: CanvasRenderingContext2D) {\n    if ((!this.stroke || this.strokeWidth === 0) && this.isEmptyStyles()) {\n      return;\n    }\n\n    if (this.shadow && !this.shadow.affectStroke) {\n      this._removeShadow(ctx);\n    }\n\n    ctx.save();\n    this._setLineDash(ctx, this.strokeDashArray);\n    ctx.beginPath();\n    this._renderTextCommon(ctx, 'strokeText');\n    ctx.closePath();\n    ctx.restore();\n  }\n\n  /**\n   * @private\n   * @param {String} method fillText or strokeText.\n   * @param {CanvasRenderingContext2D} ctx Context to render on\n   * @param {Array} line Content of the line, splitted in an array by grapheme\n   * @param {Number} left\n   * @param {Number} top\n   * @param {Number} lineIndex\n   */\n  _renderChars(\n    method: 'fillText' | 'strokeText',\n    ctx: CanvasRenderingContext2D,\n    line: Array<any>,\n    left: number,\n    top: number,\n    lineIndex: number,\n  ) {\n    const isJustify = this.textAlign.includes(JUSTIFY),\n      path = this.path,\n      shortCut =\n        !isJustify &&\n        this.charSpacing === 0 &&\n        this.isEmptyStyles(lineIndex) &&\n        !path,\n      isLtr = this.direction === LTR,\n      sign = this.direction === LTR ? 1 : -1,\n      // this was changed in the PR #7674\n      // currentDirection = ctx.canvas.getAttribute('dir');\n      currentDirection = ctx.direction;\n\n    let actualStyle,\n      nextStyle,\n      charsToRender = '',\n      charBox,\n      boxWidth = 0,\n      timeToRender,\n      drawingLeft;\n\n    ctx.save();\n    if (currentDirection !== this.direction) {\n      ctx.canvas.setAttribute('dir', isLtr ? LTR : RTL);\n      ctx.direction = isLtr ? LTR : RTL;\n      ctx.textAlign = isLtr ? LEFT : RIGHT;\n    }\n    top -= this.getHeightOfLineImpl(lineIndex) * this._fontSizeFraction;\n    if (shortCut) {\n      // render all the line in one pass without checking\n      // drawingLeft = isLtr ? left : left - this.getLineWidth(lineIndex);\n      this._renderChar(method, ctx, lineIndex, 0, line.join(''), left, top);\n      ctx.restore();\n      return;\n    }\n    for (let i = 0, len = line.length - 1; i <= len; i++) {\n      timeToRender = i === len || this.charSpacing || path;\n      charsToRender += line[i];\n      charBox = this.__charBounds[lineIndex][i] as Required<GraphemeBBox>;\n      if (boxWidth === 0) {\n        left += sign * (charBox.kernedWidth - charBox.width);\n        boxWidth += charBox.width;\n      } else {\n        boxWidth += charBox.kernedWidth;\n      }\n      if (isJustify && !timeToRender) {\n        if (this._reSpaceAndTab.test(line[i])) {\n          timeToRender = true;\n        }\n      }\n      if (!timeToRender) {\n        // if we have charSpacing, we render char by char\n        actualStyle =\n          actualStyle || this.getCompleteStyleDeclaration(lineIndex, i);\n        nextStyle = this.getCompleteStyleDeclaration(lineIndex, i + 1);\n        timeToRender = hasStyleChanged(actualStyle, nextStyle, false);\n      }\n      if (timeToRender) {\n        if (path) {\n          ctx.save();\n          ctx.translate(charBox.renderLeft, charBox.renderTop);\n          ctx.rotate(charBox.angle);\n          this._renderChar(\n            method,\n            ctx,\n            lineIndex,\n            i,\n            charsToRender,\n            -boxWidth / 2,\n            0,\n          );\n          ctx.restore();\n        } else {\n          drawingLeft = left;\n          this._renderChar(\n            method,\n            ctx,\n            lineIndex,\n            i,\n            charsToRender,\n            drawingLeft,\n            top,\n          );\n        }\n        charsToRender = '';\n        actualStyle = nextStyle;\n        left += sign * boxWidth;\n        boxWidth = 0;\n      }\n    }\n    ctx.restore();\n  }\n\n  /**\n   * This function try to patch the missing gradientTransform on canvas gradients.\n   * transforming a context to transform the gradient, is going to transform the stroke too.\n   * we want to transform the gradient but not the stroke operation, so we create\n   * a transformed gradient on a pattern and then we use the pattern instead of the gradient.\n   * this method has drawbacks: is slow, is in low resolution, needs a patch for when the size\n   * is limited.\n   * @private\n   * @param {TFiller} filler a fabric gradient instance\n   * @return {CanvasPattern} a pattern to use as fill/stroke style\n   */\n  _applyPatternGradientTransformText(filler: TFiller) {\n    // TODO: verify compatibility with strokeUniform\n    const width = this.width + this.strokeWidth,\n      height = this.height + this.strokeWidth,\n      pCanvas = createCanvasElementFor({\n        width,\n        height,\n      }),\n      pCtx = pCanvas.getContext('2d')!;\n    pCanvas.width = width;\n    pCanvas.height = height;\n    pCtx.beginPath();\n    pCtx.moveTo(0, 0);\n    pCtx.lineTo(width, 0);\n    pCtx.lineTo(width, height);\n    pCtx.lineTo(0, height);\n    pCtx.closePath();\n    pCtx.translate(width / 2, height / 2);\n    pCtx.fillStyle = filler.toLive(pCtx)!;\n    this._applyPatternGradientTransform(pCtx, filler);\n    pCtx.fill();\n    return pCtx.createPattern(pCanvas, 'no-repeat')!;\n  }\n\n  handleFiller<T extends 'fill' | 'stroke'>(\n    ctx: CanvasRenderingContext2D,\n    property: `${T}Style`,\n    filler: TFiller | string,\n  ): { offsetX: number; offsetY: number } {\n    let offsetX: number, offsetY: number;\n    if (isFiller(filler)) {\n      if (\n        (filler as Gradient<'linear'>).gradientUnits === 'percentage' ||\n        (filler as Gradient<'linear'>).gradientTransform ||\n        (filler as Pattern).patternTransform\n      ) {\n        // need to transform gradient in a pattern.\n        // this is a slow process. If you are hitting this codepath, and the object\n        // is not using caching, you should consider switching it on.\n        // we need a canvas as big as the current object caching canvas.\n        offsetX = -this.width / 2;\n        offsetY = -this.height / 2;\n        ctx.translate(offsetX, offsetY);\n        ctx[property] = this._applyPatternGradientTransformText(filler);\n        return { offsetX, offsetY };\n      } else {\n        // is a simple gradient or pattern\n        ctx[property] = filler.toLive(ctx)!;\n        return this._applyPatternGradientTransform(ctx, filler);\n      }\n    } else {\n      // is a color\n      ctx[property] = filler;\n    }\n    return { offsetX: 0, offsetY: 0 };\n  }\n\n  /**\n   * This function prepare the canvas for a stroke style, and stroke and strokeWidth\n   * need to be sent in as defined\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {CompleteTextStyleDeclaration} style with stroke and strokeWidth defined\n   * @returns\n   */\n  _setStrokeStyles(\n    ctx: CanvasRenderingContext2D,\n    {\n      stroke,\n      strokeWidth,\n    }: Pick<CompleteTextStyleDeclaration, 'stroke' | 'strokeWidth'>,\n  ) {\n    ctx.lineWidth = strokeWidth;\n    ctx.lineCap = this.strokeLineCap;\n    ctx.lineDashOffset = this.strokeDashOffset;\n    ctx.lineJoin = this.strokeLineJoin;\n    ctx.miterLimit = this.strokeMiterLimit;\n    return this.handleFiller(ctx, 'strokeStyle', stroke!);\n  }\n\n  /**\n   * This function prepare the canvas for a ill style, and fill\n   * need to be sent in as defined\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {CompleteTextStyleDeclaration} style with ill defined\n   * @returns\n   */\n  _setFillStyles(ctx: CanvasRenderingContext2D, { fill }: Pick<this, 'fill'>) {\n    return this.handleFiller(ctx, 'fillStyle', fill!);\n  }\n\n  /**\n   * @private\n   * @param {String} method\n   * @param {CanvasRenderingContext2D} ctx Context to render on\n   * @param {Number} lineIndex\n   * @param {Number} charIndex\n   * @param {String} _char\n   * @param {Number} left Left coordinate\n   * @param {Number} top Top coordinate\n   * @param {Number} lineHeight Height of the line\n   */\n  _renderChar(\n    method: 'fillText' | 'strokeText',\n    ctx: CanvasRenderingContext2D,\n    lineIndex: number,\n    charIndex: number,\n    _char: string,\n    left: number,\n    top: number,\n  ) {\n    const decl = this._getStyleDeclaration(lineIndex, charIndex),\n      fullDecl = this.getCompleteStyleDeclaration(lineIndex, charIndex),\n      shouldFill = method === 'fillText' && fullDecl.fill,\n      shouldStroke =\n        method === 'strokeText' && fullDecl.stroke && fullDecl.strokeWidth;\n\n    if (!shouldStroke && !shouldFill) {\n      return;\n    }\n    ctx.save();\n\n    ctx.font = this._getFontDeclaration(fullDecl);\n\n    if (decl.textBackgroundColor) {\n      this._removeShadow(ctx);\n    }\n    if (decl.deltaY) {\n      top += decl.deltaY;\n    }\n\n    if (shouldFill) {\n      const fillOffsets = this._setFillStyles(ctx, fullDecl);\n      ctx.fillText(\n        _char,\n        left - fillOffsets.offsetX,\n        top - fillOffsets.offsetY,\n      );\n    }\n\n    if (shouldStroke) {\n      const strokeOffsets = this._setStrokeStyles(ctx, fullDecl);\n      ctx.strokeText(\n        _char,\n        left - strokeOffsets.offsetX,\n        top - strokeOffsets.offsetY,\n      );\n    }\n\n    ctx.restore();\n  }\n\n  /**\n   * Turns the character into a 'superior figure' (i.e. 'superscript')\n   * @param {Number} start selection start\n   * @param {Number} end selection end\n   */\n  setSuperscript(start: number, end: number) {\n    this._setScript(start, end, this.superscript);\n  }\n\n  /**\n   * Turns the character into an 'inferior figure' (i.e. 'subscript')\n   * @param {Number} start selection start\n   * @param {Number} end selection end\n   */\n  setSubscript(start: number, end: number) {\n    this._setScript(start, end, this.subscript);\n  }\n\n  /**\n   * Applies 'schema' at given position\n   * @private\n   * @param {Number} start selection start\n   * @param {Number} end selection end\n   * @param {Number} schema\n   */\n  protected _setScript(\n    start: number,\n    end: number,\n    schema: {\n      size: number;\n      baseline: number;\n    },\n  ) {\n    const loc = this.get2DCursorLocation(start, true),\n      fontSize = this.getValueOfPropertyAt(\n        loc.lineIndex,\n        loc.charIndex,\n        'fontSize',\n      ),\n      dy = this.getValueOfPropertyAt(loc.lineIndex, loc.charIndex, 'deltaY'),\n      style = {\n        fontSize: fontSize * schema.size,\n        deltaY: dy + fontSize * schema.baseline,\n      };\n    this.setSelectionStyles(style, start, end);\n  }\n\n  /**\n   * @private\n   * @param {Number} lineIndex index text line\n   * @return {Number} Line left offset\n   */\n  _getLineLeftOffset(lineIndex: number): number {\n    const lineWidth = this.getLineWidth(lineIndex),\n      lineDiff = this.width - lineWidth,\n      textAlign = this.textAlign,\n      direction = this.direction,\n      isEndOfWrapping = this.isEndOfWrapping(lineIndex);\n    let leftOffset = 0;\n    if (\n      textAlign === JUSTIFY ||\n      (textAlign === JUSTIFY_CENTER && !isEndOfWrapping) ||\n      (textAlign === JUSTIFY_RIGHT && !isEndOfWrapping) ||\n      (textAlign === JUSTIFY_LEFT && !isEndOfWrapping)\n    ) {\n      return 0;\n    }\n    if (textAlign === CENTER) {\n      leftOffset = lineDiff / 2;\n    }\n    if (textAlign === RIGHT) {\n      leftOffset = lineDiff;\n    }\n    if (textAlign === JUSTIFY_CENTER) {\n      leftOffset = lineDiff / 2;\n    }\n    if (textAlign === JUSTIFY_RIGHT) {\n      leftOffset = lineDiff;\n    }\n    if (direction === RTL) {\n      if (textAlign === RIGHT || textAlign === JUSTIFY_RIGHT) {\n        leftOffset = 0;\n      } else if (textAlign === LEFT || textAlign === JUSTIFY_LEFT) {\n        leftOffset = -lineDiff;\n      } else if (textAlign === CENTER || textAlign === JUSTIFY_CENTER) {\n        leftOffset = -lineDiff / 2;\n      }\n    }\n    return leftOffset;\n  }\n\n  /**\n   * @private\n   */\n  _clearCache() {\n    this._forceClearCache = false;\n    this.__lineWidths = [];\n    this.__lineHeights = [];\n    this.__charBounds = [];\n  }\n\n  /**\n   * Measure a single line given its index. Used to calculate the initial\n   * text bounding box. The values are calculated and stored in __lineWidths cache.\n   * @private\n   * @param {Number} lineIndex line number\n   * @return {Number} Line width\n   */\n  getLineWidth(lineIndex: number): number {\n    if (this.__lineWidths[lineIndex] !== undefined) {\n      return this.__lineWidths[lineIndex];\n    }\n\n    const { width } = this.measureLine(lineIndex);\n    this.__lineWidths[lineIndex] = width;\n    return width;\n  }\n\n  _getWidthOfCharSpacing() {\n    //*PMW* change char spacing to be applied the same on every size\n    // if (this.charSpacing !== 0) {\n    //   return this.fontSize * this.charSpacing / 1000;\n    // }\n    return this.charSpacing;\n  }\n\n  /**\n   * Retrieves the value of property at given character position\n   * @param {Number} lineIndex the line number\n   * @param {Number} charIndex the character number\n   * @param {String} property the property name\n   * @returns the value of 'property'\n   */\n  getValueOfPropertyAt<T extends StylePropertiesType>(\n    lineIndex: number,\n    charIndex: number,\n    property: T,\n  ): this[T] {\n    const charStyle = this._getStyleDeclaration(lineIndex, charIndex);\n    return (charStyle[property] ?? this[property]) as this[T];\n  }\n\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} ctx Context to render on\n   */\n  _renderTextDecoration(\n    ctx: CanvasRenderingContext2D,\n    type: 'underline' | 'linethrough' | 'overline' | 'squigglyline',\n  ) {\n    if (!this[type] && !this.styleHas(type)) {\n      return;\n    }\n    let topOffset = this._getTopOffset();\n    const leftOffset = this._getLeftOffset(),\n      path = this.path,\n      charSpacing = this._getWidthOfCharSpacing(),\n      offsetAligner =\n        type === 'linethrough' ? 0.5 : type === 'overline' ? 1 : 0,\n      offsetY = this.offsets[type];\n    for (let i = 0, len = this._textLines.length; i < len; i++) {\n      const heightOfLine = this.getHeightOfLine(i);\n      if (!this[type] && !this.styleHas(type, i)) {\n        topOffset += heightOfLine;\n        continue;\n      }\n      const line = this._textLines[i];\n      const maxHeight = heightOfLine / this.lineHeight;\n      const lineLeftOffset = this._getLineLeftOffset(i);\n      let boxStart = 0;\n      let boxWidth = 0;\n      let lastDecoration = this.getValueOfPropertyAt(i, 0, type);\n      let lastFill = this.getValueOfPropertyAt(i, 0, FILL);\n      let lastTickness = this.getValueOfPropertyAt(\n        i,\n        0,\n        TEXT_DECORATION_THICKNESS,\n      );\n      let currentDecoration = lastDecoration;\n      let currentFill = lastFill;\n      let currentTickness = lastTickness;\n      const top = topOffset + maxHeight * (1 - this._fontSizeFraction);\n      let size = this.getHeightOfChar(i, 0);\n      let dy = this.getValueOfPropertyAt(i, 0, 'deltaY');\n      for (let j = 0, jlen = line.length; j < jlen; j++) {\n        const charBox = this.__charBounds[i][j] as Required<GraphemeBBox>;\n        currentDecoration = this.getValueOfPropertyAt(i, j, type);\n        currentFill = this.getValueOfPropertyAt(i, j, FILL);\n        currentTickness = this.getValueOfPropertyAt(\n          i,\n          j,\n          TEXT_DECORATION_THICKNESS,\n        );\n        const currentSize = this.getHeightOfChar(i, j);\n        const currentDy = this.getValueOfPropertyAt(i, j, 'deltaY');\n        if (path && currentDecoration && currentFill) {\n          const finalTickness = (this.fontSize * currentTickness) / 1000;\n          ctx.save();\n          // bug? verify lastFill is a valid fill here.\n          ctx.fillStyle = this.getFillForTextDecoration(\n            ctx,\n            type,\n            lastFill as string,\n          );\n          ctx.translate(charBox.renderLeft, charBox.renderTop);\n          ctx.rotate(charBox.angle);\n          this.fillTextDecorationRect(\n            ctx,\n            type,\n            -charBox.kernedWidth / 2,\n            offsetY * currentSize + currentDy - offsetAligner * finalTickness,\n            charBox.kernedWidth,\n            finalTickness,\n          );\n          ctx.restore();\n        } else if (\n          (currentDecoration !== lastDecoration ||\n            currentFill !== lastFill ||\n            currentSize !== size ||\n            currentTickness !== lastTickness ||\n            currentDy !== dy) &&\n          boxWidth > 0\n        ) {\n          const finalTickness = (this.fontSize * lastTickness) / 1000;\n          let drawStart = leftOffset + lineLeftOffset + boxStart;\n          if (this.direction === RTL) {\n            drawStart = this.width - drawStart - boxWidth;\n          }\n          if (lastDecoration && lastFill && lastTickness) {\n            // bug? verify lastFill is a valid fill here.\n            ctx.fillStyle = this.getFillForTextDecoration(\n              ctx,\n              type,\n              lastFill as string,\n            );\n            this.fillTextDecorationRect(\n              ctx,\n              type,\n              drawStart,\n              top + offsetY * size + dy - offsetAligner * finalTickness,\n              boxWidth,\n              finalTickness,\n            );\n          }\n          boxStart = charBox.left;\n          boxWidth = charBox.width;\n          lastDecoration = currentDecoration;\n          lastTickness = currentTickness;\n          lastFill = currentFill;\n          size = currentSize;\n          dy = currentDy;\n        } else {\n          boxWidth += charBox.kernedWidth;\n        }\n      }\n      let drawStart = leftOffset + lineLeftOffset + boxStart;\n      if (this.direction === RTL) {\n        drawStart = this.width - drawStart - boxWidth;\n      }\n      ctx.fillStyle = this.getFillForTextDecoration(\n        ctx,\n        type,\n        currentFill as string,\n      );\n      const finalTickness = (this.fontSize * currentTickness) / 1000;\n      currentDecoration &&\n        currentFill &&\n        currentTickness &&\n        this.fillTextDecorationRect(\n          ctx,\n          type,\n          drawStart,\n          top + offsetY * size + dy - offsetAligner * finalTickness,\n          boxWidth - charSpacing,\n          finalTickness,\n        );\n      topOffset += heightOfLine;\n    }\n\n    // if there is text background color no\n    // other shadows should be casted\n    // *PMW* need shadow to be applied on text with styles as well,\n    // this._removeShadow(ctx);\n  }\n\n  /**\n   *  *PMW*\n   * Handle squigglyline\n   * @private\n   */\n  private fillTextDecorationRect(\n    ctx: CanvasRenderingContext2D,\n    type: 'underline' | 'linethrough' | 'overline' | 'squigglyline',\n    x: number,\n    y: number,\n    w: number,\n    h: number,\n  ) {\n    if (type === 'squigglyline') {\n      const polyPoints = [],\n        scaleX = 0.35,\n        scaleY = 0.45,\n        funct = function (x: number): number {\n          const g = x % 6;\n          if (g <= 3) {\n            return g * 5;\n          }\n\n          return (6 - g) * 5;\n        };\n\n      for (let x = 0; x < w; x += 0.5) {\n        polyPoints.push({\n          x: x - 10,\n          y: funct(x * scaleX) * scaleY,\n        });\n      }\n\n      for (let j = 0; j < polyPoints.length; j++) {\n        ctx.fillRect(x + polyPoints[j].x + 8, y + polyPoints[j].y, 2, 2);\n      }\n    } else {\n      ctx.fillRect(x, y, w, h);\n    }\n  }\n\n  /**\n   *  *PMW*\n   * Handle squigglyline, gradient fill and pattern fill for text decoration\n   * @private\n   */\n  private getFillForTextDecoration(\n    ctx: CanvasRenderingContext2D,\n    type: 'underline' | 'linethrough' | 'overline' | 'squigglyline',\n    fill: string | TFiller | null,\n  ): CanvasPattern | string {\n    if (type === 'squigglyline') {\n      return this.squigglylineColor;\n    }\n\n    if (\n      fill &&\n      typeof fill !== 'string' &&\n      'colorStops' in fill &&\n      fill.colorStops.length\n    ) {\n      return fill.colorStops[0].color;\n    } else if (fill && typeof fill !== 'string' && 'source' in fill) {\n      //Use pattern for underline, linethrough on text mask\n      const pattern = ctx.createPattern(fill.source, 'repeat');\n      if (pattern) {\n        return pattern;\n      }\n    }\n\n    return fill as string;\n  }\n\n  /**\n   * *PMW*\n   * Draws a background for the object big as its untrasformed dimensions\n   * @private\n   * @param {CanvasRenderingContext2D} ctx Context to render on\n   */\n  _renderBackground(ctx: CanvasRenderingContext2D) {\n    if (!this.backgroundColor) {\n      return;\n    }\n    const dim = this._getNonTransformedDimensions();\n    let scaleX = this.scaleX,\n      scaleY = this.scaleY;\n\n    ctx.fillStyle = this.backgroundColor;\n    if (this.group) {\n      scaleX *= this.group.scaleX;\n      scaleY *= this.group.scaleY;\n    }\n\n    ctx.fillRect(\n      -dim.x / 2 - this.padding / scaleX,\n      -dim.y / 2 - this.padding / scaleY,\n      dim.x + (this.padding / scaleX) * 2,\n      dim.y + (this.padding / scaleY) * 2,\n    );\n    // if there is background color no other shadows\n    // should be casted\n    this._removeShadow(ctx);\n  }\n\n  getCharOffset(position: number) {\n    let topOffset = 0,\n      leftOffset = 0;\n\n    const cursorPosition = this.get2DCursorLocation(position),\n      charIndex = cursorPosition.charIndex,\n      lineIndex = cursorPosition.lineIndex;\n    for (let i = 0; i < lineIndex; i++) {\n      topOffset += this.getHeightOfLine(i);\n    }\n    const lineLeftOffset = this._getLineLeftOffset(lineIndex);\n    const bound = this.__charBounds[lineIndex][charIndex];\n    bound && (leftOffset = bound.left);\n    if (\n      this.charSpacing !== 0 &&\n      charIndex === this._textLines[lineIndex].length\n    ) {\n      leftOffset -= this._getWidthOfCharSpacing();\n    }\n    return {\n      x: lineLeftOffset + (leftOffset > 0 ? leftOffset : 0),\n      y: topOffset,\n    };\n  }\n\n  /**\n   * *PMW*\n   * Find new selection index representing start of current word according to current selection index\n   * @param {Number} startFrom Current selection index\n   * @return {Number} selection start index\n   */\n  findSelectedWordLeft(startFrom: number): number {\n    let offset = 0,\n      index = startFrom - 1;\n\n    while (/[^\\n -&(-/:-@[-`{-~0-9]/.test(this._text[index]) && index > -1) {\n      offset++;\n      index--;\n    }\n\n    return startFrom - offset;\n  }\n\n  /**\n   * *PMW*\n   * Find new selection index representing end of current word according to current selection index\n   * @param {Number} startFrom Current selection index\n   * @return {Number} selection end index\n   */\n  findSelectedWordRight(startFrom: number): number {\n    let offset = 0,\n      index = startFrom;\n\n    while (\n      /[^\\n -&(-/:-@[-`{-~0-9]/.test(this._text[index]) &&\n      index < this._text.length\n    ) {\n      offset++;\n      index++;\n    }\n\n    return startFrom + offset;\n  }\n\n  /**\n   * return font declaration string for canvas context\n   * @param {Object} [styleObject] object\n   * @returns {String} font declaration formatted for canvas context.\n   */\n  _getFontDeclaration(\n    {\n      fontFamily = this.fontFamily,\n      fontStyle = this.fontStyle,\n      fontWeight = this.fontWeight,\n      fontSize = this.fontSize,\n    }: Partial<\n      Pick<\n        TextStyleDeclaration,\n        'fontFamily' | 'fontStyle' | 'fontWeight' | 'fontSize'\n      >\n    > = {},\n    forMeasuring?: boolean,\n  ): string {\n    const parsedFontFamily =\n      fontFamily.includes(\"'\") ||\n      fontFamily.includes('\"') ||\n      fontFamily.includes(',') ||\n      FabricText.genericFonts.includes(fontFamily.toLowerCase())\n        ? fontFamily\n        : `\"${fontFamily}\"`;\n    return [\n      fontStyle,\n      fontWeight,\n      `${forMeasuring ? this.CACHE_FONT_SIZE : fontSize}px`,\n      parsedFontFamily,\n    ].join(' ');\n  }\n\n  /**\n   * Renders text instance on a specified context\n   * @param {CanvasRenderingContext2D} ctx Context to render on\n   */\n  render(ctx: CanvasRenderingContext2D) {\n    if (!this.visible) {\n      return;\n    }\n    if (\n      this.canvas &&\n      this.canvas.skipOffscreen &&\n      !this.group &&\n      !this.isOnScreen()\n    ) {\n      return;\n    }\n    if (this._forceClearCache) {\n      this.initDimensions();\n    }\n    super.render(ctx);\n  }\n\n  /**\n   * Override this method to customize grapheme splitting\n   * @todo the util `graphemeSplit` needs to be injectable in some way.\n   * is more comfortable to inject the correct util rather than having to override text\n   * in the middle of the prototype chain\n   * @param {string} value\n   * @returns {string[]} array of graphemes\n   */\n  graphemeSplit(value: string): string[] {\n    return graphemeSplit(value);\n  }\n\n  /**\n   * Returns the text as an array of lines.\n   * @param {String} text text to split\n   * @returns  Lines in the text\n   */\n  _splitTextIntoLines(text: string): TextLinesInfo {\n    const lines = text.split(this._reNewline),\n      newLines = new Array<string[]>(lines.length),\n      newLine = ['\\n'];\n    let newText: string[] = [];\n    for (let i = 0; i < lines.length; i++) {\n      newLines[i] = this.graphemeSplit(lines[i]);\n      newText = newText.concat(newLines[i], newLine);\n    }\n    newText.pop();\n    return {\n      _unwrappedLines: newLines,\n      lines: lines,\n      graphemeText: newText,\n      graphemeLines: newLines,\n    };\n  }\n\n  /**\n   * Returns object representation of an instance\n   * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n   * @return {Object} Object representation of an instance\n   */\n  toObject<\n    T extends Omit<Props & TClassProperties<this>, keyof SProps>,\n    K extends keyof T = never,\n  >(propertiesToInclude: K[] = []): Pick<T, K> & SProps {\n    return {\n      ...super.toObject([...additionalProps, ...propertiesToInclude] as K[]),\n      styles: stylesToArray(this.styles, this.text),\n      ...(this.path ? { path: this.path.toObject() } : {}),\n    };\n  }\n\n  set(key: string | any, value?: any) {\n    const { textLayoutProperties } = this.constructor as typeof FabricText;\n    super.set(key, value);\n    let needsDims = false;\n    let isAddingPath = false;\n    if (typeof key === 'object') {\n      for (const _key in key) {\n        if (_key === 'path') {\n          this.setPathInfo();\n        }\n        needsDims = needsDims || textLayoutProperties.includes(_key);\n        isAddingPath = isAddingPath || _key === 'path';\n      }\n    } else {\n      needsDims = textLayoutProperties.includes(key);\n      isAddingPath = key === 'path';\n    }\n    if (isAddingPath) {\n      this.setPathInfo();\n    }\n    if (needsDims && this.initialized) {\n      this.initDimensions();\n      this.setCoords();\n    }\n    return this;\n  }\n\n  /**\n   * Returns complexity of an instance\n   * @return {Number} complexity\n   */\n  complexity(): number {\n    return 1;\n  }\n\n  /**\n   * List of generic font families\n   * @see https://developer.mozilla.org/en-US/docs/Web/CSS/font-family#generic-name\n   */\n  static genericFonts = [\n    'serif',\n    'sans-serif',\n    'monospace',\n    'cursive',\n    'fantasy',\n    'system-ui',\n    'ui-serif',\n    'ui-sans-serif',\n    'ui-monospace',\n    'ui-rounded',\n    'math',\n    'emoji',\n    'fangsong',\n  ];\n\n  /* _FROM_SVG_START_ */\n\n  /**\n   * List of attribute names to account for when parsing SVG element (used by {@link FabricText.fromElement})\n   * @see: http://www.w3.org/TR/SVG/text.html#TextElement\n   */\n  static ATTRIBUTE_NAMES = SHARED_ATTRIBUTES.concat(\n    'x',\n    'y',\n    'dx',\n    'dy',\n    'font-family',\n    'font-style',\n    'font-weight',\n    'font-size',\n    'letter-spacing',\n    'text-decoration',\n    'text-anchor',\n  );\n\n  /**\n   * Returns FabricText instance from an SVG element (<b>not yet implemented</b>)\n   * @param {HTMLElement} element Element to parse\n   * @param {Object} [options] Options object\n   */\n  static async fromElement(\n    element: HTMLElement | SVGElement,\n    options?: Abortable,\n    cssRules?: CSSRules,\n  ) {\n    const parsedAttributes = parseAttributes(\n      element,\n      FabricText.ATTRIBUTE_NAMES,\n      cssRules,\n    );\n\n    const {\n      textAnchor = LEFT as typeof LEFT | typeof CENTER | typeof RIGHT,\n      textDecoration = '',\n      dx = 0,\n      dy = 0,\n      top = 0,\n      left = 0,\n      fontSize = DEFAULT_SVG_FONT_SIZE,\n      strokeWidth = 1,\n      ...restOfOptions\n    } = { ...options, ...parsedAttributes };\n\n    const textContent = normalizeWs(element.textContent || '').trim();\n\n    // this code here is probably the usual issue for SVG center find\n    // this can later looked at again and probably removed.\n\n    const text = new this(textContent, {\n        left: left + dx,\n        top: top + dy,\n        underline: textDecoration.includes('underline'),\n        overline: textDecoration.includes('overline'),\n        linethrough: textDecoration.includes('line-through'),\n        /*PMW*/\n        squigglyline: textDecoration.includes('squiggly-line'),\n        // we initialize this as 0\n        strokeWidth: 0,\n        fontSize,\n        ...restOfOptions,\n      }),\n      textHeightScaleFactor = text.getScaledHeight() / text.height,\n      lineHeightDiff =\n        (text.height + text.strokeWidth) * text.lineHeight - text.height,\n      scaledDiff = lineHeightDiff * textHeightScaleFactor,\n      textHeight = text.getScaledHeight() + scaledDiff;\n\n    let offX = 0;\n    /*\n      Adjust positioning:\n        x/y attributes in SVG correspond to the bottom-left corner of text bounding box\n        fabric output by default at top, left.\n    */\n    if (textAnchor === CENTER) {\n      offX = text.getScaledWidth() / 2;\n    }\n    if (textAnchor === RIGHT) {\n      offX = text.getScaledWidth();\n    }\n    text.set({\n      left: text.left - offX,\n      top:\n        text.top -\n        (textHeight - text.fontSize * (0.07 + text._fontSizeFraction)) /\n          text.lineHeight,\n      strokeWidth,\n    });\n    return text;\n  }\n\n  /* _FROM_SVG_END_ */\n\n  /**\n   * Returns FabricText instance from an object representation\n   * @param {Object} object plain js Object to create an instance from\n   * @returns {Promise<FabricText>}\n   */\n  static fromObject<\n    T extends TOptions<SerializedTextProps>,\n    S extends FabricText,\n  >(object: T) {\n    return this._fromObject<S>(\n      {\n        ...object,\n        styles: stylesFromArray(object.styles || {}, object.text || ''),\n      },\n      {\n        extraParam: 'text',\n      },\n    );\n  }\n}\n\napplyMixins(FabricText, [TextSVGExportMixin]);\nclassRegistry.setClass(FabricText);\nclassRegistry.setSVGClass(FabricText);\n"],"names":["measuringContext","FabricText","StyledText","getDefaults","super","ownDefaults","constructor","text","options","_defineProperty","Object","assign","this","setOptions","styles","initialized","path","setPathInfo","initDimensions","setCoords","segmentsInfo","getPathSegmentsInfo","_splitText","newLines","_splitTextIntoLines","textLines","lines","_textLines","graphemeLines","_unwrappedTextLines","_unwrappedLines","_text","graphemeText","_clearCache","dirty","width","height","calcTextWidth","cursorWidth","MIN_TEXT_WIDTH","calcTextHeight","textAlign","includes","JUSTIFY","enlargeSpaces","diffSpace","currentLineWidth","numberOfSpaces","accumulatedSpace","line","charBound","spaces","i","len","length","isEndOfWrapping","getLineWidth","match","_reSpacesAndTabs","j","__charBounds","_reSpaceAndTab","test","kernedWidth","left","lineIndex","missingNewlineOffset","_lineIndex","get2DCursorLocation","selectionStart","skipWrapping","charIndex","toString","complexity","fontFamily","_getCacheCanvasDimensions","dims","fontSize","zoomX","zoomY","cacheExpansionFactor","_render","ctx","isNotVisible","_setTextStyles","_renderTextLinesBackground","_renderTextDecoration","_renderText","paintFirst","STROKE","_renderTextStroke","_renderTextFill","charStyle","forMeasuring","textBaseline","pathAlign","CENTER","TOP","BOTTOM","font","_getFontDeclaration","maxWidth","_renderTextLine","method","top","_renderChars","textBackgroundColor","styleHas","originalFill","fillStyle","leftOffset","_getLeftOffset","lineTopOffset","_getTopOffset","heightOfLine","getHeightOfLine","jlen","lineLeftOffset","_getLineLeftOffset","drawStart","currentColor","boxWidth","boxStart","lastColor","getValueOfPropertyAt","bgHeight","getHeightOfLineImpl","charBox","save","translate","renderLeft","renderTop","rotate","angle","fillRect","_fontSizeFraction","restore","direction","RTL","_removeShadow","_measureChar","_char","previousChar","prevCharStyle","fontCache","cache","getFontCache","fontDeclaration","couple","stylesAreEqual","fontMultiplier","CACHE_FONT_SIZE","coupleWidth","previousWidth","has","get","undefined","canvas","createCanvasElementFor","getContext","getMeasuringContext","measureText","set","getHeightOfChar","measureLine","lineInfo","_measureLine","charSpacing","_getWidthOfCharSpacing","prevGrapheme","graphemeInfo","reverse","pathSide","RIGHT","llength","lineBounds","Array","grapheme","_getGraphemeBox","deltaY","positionInPath","totalPathLength","LEFT","pathStartOffset","_setGraphemeOnPath","numOfSpaces","centerPosition","info","getPointOnPath","x","pathOffset","y","Math","PI","skipLeft","style","getCompleteStyleDeclaration","prevStyle","box","previousBox","lh","__lineHeights","maxHeight","max","_fontSizeMult","lineHeight","LTR","_renderTextCommon","lineHeights","fill","FILL","stroke","strokeWidth","isEmptyStyles","shadow","affectStroke","_setLineDash","strokeDashArray","beginPath","closePath","isJustify","shortCut","isLtr","sign","currentDirection","actualStyle","nextStyle","timeToRender","drawingLeft","charsToRender","setAttribute","_renderChar","join","hasStyleChanged","_applyPatternGradientTransformText","filler","pCanvas","pCtx","moveTo","lineTo","toLive","_applyPatternGradientTransform","createPattern","handleFiller","property","offsetX","offsetY","isFiller","gradientUnits","gradientTransform","patternTransform","_setStrokeStyles","_ref","lineWidth","lineCap","strokeLineCap","lineDashOffset","strokeDashOffset","lineJoin","strokeLineJoin","miterLimit","strokeMiterLimit","_setFillStyles","_ref2","decl","_getStyleDeclaration","fullDecl","shouldFill","shouldStroke","fillOffsets","fillText","strokeOffsets","strokeText","setSuperscript","start","end","_setScript","superscript","setSubscript","subscript","schema","loc","dy","size","baseline","setSelectionStyles","lineDiff","JUSTIFY_CENTER","JUSTIFY_RIGHT","JUSTIFY_LEFT","_forceClearCache","__lineWidths","_charStyle$property","type","topOffset","offsetAligner","offsets","lastDecoration","lastFill","lastTickness","TEXT_DECORATION_THICKNESS","currentDecoration","currentFill","currentTickness","currentSize","currentDy","finalTickness","getFillForTextDecoration","fillTextDecorationRect","w","h","polyPoints","scaleX","scaleY","funct","g","push","squigglylineColor","colorStops","color","pattern","source","_renderBackground","backgroundColor","dim","_getNonTransformedDimensions","group","padding","getCharOffset","position","cursorPosition","bound","findSelectedWordLeft","startFrom","offset","index","findSelectedWordRight","fontStyle","fontWeight","arguments","parsedFontFamily","genericFonts","toLowerCase","render","visible","skipOffscreen","isOnScreen","graphemeSplit","value","split","_reNewline","newLine","newText","concat","pop","toObject","propertiesToInclude","additionalProps","stylesToArray","key","textLayoutProperties","needsDims","isAddingPath","_key","fromElement","element","cssRules","parsedAttributes","parseAttributes","ATTRIBUTE_NAMES","textAnchor","textDecoration","dx","DEFAULT_SVG_FONT_SIZE","restOfOptions","normalizeWs","textContent","trim","underline","overline","linethrough","squigglyline","textHeightScaleFactor","getScaledHeight","scaledDiff","textHeight","offX","getScaledWidth","fromObject","object","_fromObject","stylesFromArray","extraParam","cacheProperties","textDefaultValues","SHARED_ATTRIBUTES","applyMixins","TextSVGExportMixin","classRegistry","setClass","setSVGClass"],"mappings":"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"}