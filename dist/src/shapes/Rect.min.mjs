import{defineProperty as t}from"../../_virtual/_rollupPluginBabelHelpers.min.mjs";import{kRect as e}from"../constants.min.mjs";import{SHARED_ATTRIBUTES as i}from"../parser/attributes.min.mjs";import{parseAttributes as r}from"../parser/parseAttributes.min.mjs";import{classRegistry as s}from"../ClassRegistry.min.mjs";import{FabricObject as o}from"./Object/FabricObject.min.mjs";import{cacheProperties as n}from"./Object/defaultValues.min.mjs";const h={uniformRoundness:!1,rx:0,ry:0},m=["rx","ry"];class a extends o{static getDefaults(){return{...super.getDefaults(),...a.ownDefaults}}constructor(t){super(),Object.assign(this,a.ownDefaults),this.setOptions(t),this._initRxRy()}_initRxRy(){const{rx:t,ry:e}=this;t&&!e?this.ry=t:e&&!t&&(this.rx=e)}_render(t){const{width:i,height:r}=this,s=-i/2,o=-r/2;let n=this.rx?this.rx:0,h=this.ry?this.ry:0;const m=0!==n||0!==h;if(this.uniformRoundness){const t=this.getObjectScaling();n/=t.x,h/=t.y}n=Math.min(n,i/2),h=Math.min(h,r/2),t.beginPath(),t.moveTo(s+n,o),t.lineTo(s+i-n,o),m&&t.bezierCurveTo(s+i-e*n,o,s+i,o+e*h,s+i,o+h),t.lineTo(s+i,o+r-h),m&&t.bezierCurveTo(s+i,o+r-e*h,s+i-e*n,o+r,s+i-n,o+r),t.lineTo(s+n,o+r),m&&t.bezierCurveTo(s+e*n,o+r,s,o+r-e*h,s,o+r-h),t.lineTo(s,o+h),m&&t.bezierCurveTo(s,o+e*h,s+e*n,o,s+n,o),t.closePath(),this._renderPaintInOrder(t)}toObject(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return super.toObject([...m,...t])}_toSVG(){const{width:t,height:e,rx:i,ry:r}=this;return["<rect ","COMMON_PARTS",`x="${-t/2}" y="${-e/2}" rx="${i}" ry="${r}" width="${t}" height="${e}" />\n`]}static async fromElement(t,e,i){const{left:s=0,top:o=0,width:n=0,height:h=0,visible:m=!0,...a}=r(t,this.ATTRIBUTE_NAMES,i);return new this({...e,...a,left:s,top:o,width:n,height:h,visible:Boolean(m&&n&&h)})}}t(a,"type","Rect"),t(a,"cacheProperties",[...n,...m]),t(a,"ownDefaults",h),t(a,"ATTRIBUTE_NAMES",[...i,"x","y","rx","ry","width","height"]),s.setClass(a),s.setSVGClass(a);export{a as Rect,h as rectDefaultValues};
//# sourceMappingURL=Rect.min.mjs.map
