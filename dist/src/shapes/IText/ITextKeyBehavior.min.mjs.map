{"version":3,"file":"ITextKeyBehavior.min.mjs","sources":["../../../../src/shapes/IText/ITextKeyBehavior.ts"],"sourcesContent":["import { config } from '../../config';\nimport { getFabricDocument, getEnv } from '../../env';\nimport { capValue } from '../../util/misc/capValue';\nimport type { ITextEvents } from './ITextBehavior';\nimport { ITextBehavior } from './ITextBehavior';\nimport type { TKeyMapIText } from './constants';\nimport type { TOptions } from '../../typedefs';\nimport type { TextProps, SerializedTextProps } from '../Text/Text';\nimport { getDocumentFromElement } from '../../util/dom_misc';\nimport { CHANGED, LEFT, RIGHT } from '../../constants';\nimport type { IText } from './IText';\nimport type { TextStyleDeclaration } from '../Text/StyledText';\n\nexport abstract class ITextKeyBehavior<\n  Props extends TOptions<TextProps> = Partial<TextProps>,\n  SProps extends SerializedTextProps = SerializedTextProps,\n  EventSpec extends ITextEvents = ITextEvents,\n> extends ITextBehavior<Props, SProps, EventSpec> {\n  /**\n   * For functionalities on keyDown\n   * Map a special key to a function of the instance/prototype\n   * If you need different behavior for ESC or TAB or arrows, you have to change\n   * this map setting the name of a function that you build on the IText or\n   * your prototype.\n   * the map change will affect all Instances unless you need for only some text Instances\n   * in that case you have to clone this object and assign your Instance.\n   * this.keysMap = Object.assign({}, this.keysMap);\n   * The function must be in IText.prototype.myFunction And will receive event as args[0]\n   */\n  declare keysMap: TKeyMapIText;\n\n  declare keysMapRtl: TKeyMapIText;\n\n  /**\n   * For functionalities on keyUp + ctrl || cmd\n   */\n  declare ctrlKeysMapUp: TKeyMapIText;\n\n  /**\n   * For functionalities on keyDown + ctrl || cmd\n   */\n  declare ctrlKeysMapDown: TKeyMapIText;\n\n  declare hiddenTextarea: HTMLTextAreaElement | null;\n\n  /**\n   * DOM container to append the hiddenTextarea.\n   * An alternative to attaching to the document.body.\n   * Useful to reduce laggish redraw of the full document.body tree and\n   * also with modals event capturing that won't let the textarea take focus.\n   * @type HTMLElement\n   * @default\n   */\n  declare hiddenTextareaContainer?: HTMLElement | null;\n\n  declare private _clickHandlerInitialized: boolean;\n  declare private _copyDone: boolean;\n  declare private fromPaste: boolean;\n\n  /**\n   * Initializes hidden textarea (needed to bring up keyboard in iOS)\n   */\n  initHiddenTextarea() {\n    const doc =\n      (this.canvas && getDocumentFromElement(this.canvas.getElement())) ||\n      getFabricDocument();\n    const textarea = doc.createElement('textarea');\n    Object.entries({\n      autocapitalize: 'off',\n      autocorrect: 'off',\n      autocomplete: 'off',\n      spellcheck: 'false',\n      'data-fabric': 'textarea',\n      wrap: 'off',\n    }).map(([attribute, value]) => textarea.setAttribute(attribute, value));\n    const { top, left, fontSize } = this._calcTextareaPosition();\n    // line-height: 1px; was removed from the style to fix this:\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=870966\n    textarea.style.cssText = `position: absolute; top: ${top}; left: ${left}; z-index: -999; opacity: 0; width: 1px; height: 1px; font-size: 1px; padding-top: ${fontSize};`;\n\n    (this.hiddenTextareaContainer || doc.body).appendChild(textarea);\n\n    Object.entries({\n      blur: 'blur',\n      keydown: 'onKeyDown',\n      keyup: 'onKeyUp',\n      input: 'onInput',\n      copy: 'copy',\n      cut: 'copy',\n      paste: 'paste',\n      compositionstart: 'onCompositionStart',\n      compositionupdate: 'onCompositionUpdate',\n      compositionend: 'onCompositionEnd',\n    } as Record<string, keyof this>).map(([eventName, handler]) =>\n      textarea.addEventListener(\n        eventName,\n        (this[handler] as EventListener).bind(this),\n      ),\n    );\n    this.hiddenTextarea = textarea;\n  }\n\n  /**\n   * Override this method to customize cursor behavior on textbox blur\n   */\n  blur() {\n    this.abortCursorAnimation();\n  }\n\n  /**\n   * Handles keydown event\n   * only used for arrows and combination of modifier keys.\n   * @param {KeyboardEvent} e Event object\n   */\n  onKeyDown(e: KeyboardEvent) {\n    if (!this.isEditing) {\n      return;\n    }\n    const keyMap = this.direction === 'rtl' ? this.keysMapRtl : this.keysMap;\n    if (e.keyCode in keyMap) {\n      (this[keyMap[e.keyCode] as keyof this] as (arg: KeyboardEvent) => void)(\n        e,\n      );\n    } else if (e.keyCode in this.ctrlKeysMapDown && (e.ctrlKey || e.metaKey)) {\n      (\n        this[this.ctrlKeysMapDown[e.keyCode] as keyof this] as (\n          arg: KeyboardEvent,\n        ) => void\n      )(e);\n    } else {\n      return;\n    }\n    e.stopImmediatePropagation();\n    e.preventDefault();\n    if (e.keyCode >= 33 && e.keyCode <= 40) {\n      // if i press an arrow key just update selection\n      this.inCompositionMode = false;\n      this.clearContextTop();\n      this.renderCursorOrSelection();\n    } else {\n      this.canvas && this.canvas.requestRenderAll();\n    }\n  }\n\n  /**\n   * Handles keyup event\n   * We handle KeyUp because ie11 and edge have difficulties copy/pasting\n   * if a copy/cut event fired, keyup is dismissed\n   * @param {KeyboardEvent} e Event object\n   */\n  onKeyUp(e: KeyboardEvent) {\n    if (!this.isEditing || this._copyDone || this.inCompositionMode) {\n      this._copyDone = false;\n      return;\n    }\n    if (e.keyCode in this.ctrlKeysMapUp && (e.ctrlKey || e.metaKey)) {\n      (\n        this[this.ctrlKeysMapUp[e.keyCode] as keyof this] as (\n          arg: KeyboardEvent,\n        ) => void\n      )(e);\n    } else {\n      return;\n    }\n    e.stopImmediatePropagation();\n    e.preventDefault();\n    this.canvas && this.canvas.requestRenderAll();\n  }\n\n  /**\n   * Handles onInput event\n   * @param {Event} e Event object\n   */\n  onInput(this: this & { hiddenTextarea: HTMLTextAreaElement }, e: Event) {\n    const fromPaste = this.fromPaste;\n    const { value, selectionStart, selectionEnd } = this.hiddenTextarea;\n    this.fromPaste = false;\n    e && e.stopPropagation();\n    if (!this.isEditing) {\n      return;\n    }\n    const updateAndFire = () => {\n      this.updateFromTextArea();\n      this.fire(CHANGED);\n      if (this.canvas) {\n        this.canvas.fire('text:changed', { target: this as unknown as IText });\n        this.canvas.requestRenderAll();\n      }\n    };\n    if (this.hiddenTextarea.value === '') {\n      this.styles = {};\n      updateAndFire();\n      return;\n    }\n    // decisions about style changes.\n    const nextText = this._splitTextIntoLines(value).graphemeText,\n      charCount = this._text.length,\n      nextCharCount = nextText.length,\n      _selectionStart = this.selectionStart,\n      _selectionEnd = this.selectionEnd,\n      selection = _selectionStart !== _selectionEnd;\n    let copiedStyle: TextStyleDeclaration[] | undefined,\n      removedText,\n      charDiff = nextCharCount - charCount,\n      removeFrom,\n      removeTo;\n\n    const textareaSelection = this.fromStringToGraphemeSelection(\n      selectionStart,\n      selectionEnd,\n      value,\n    );\n    const backDelete = _selectionStart > textareaSelection.selectionStart;\n\n    if (selection) {\n      removedText = this._text.slice(_selectionStart, _selectionEnd);\n      charDiff += _selectionEnd - _selectionStart;\n    } else if (nextCharCount < charCount) {\n      if (backDelete) {\n        removedText = this._text.slice(_selectionEnd + charDiff, _selectionEnd);\n      } else {\n        removedText = this._text.slice(\n          _selectionStart,\n          _selectionStart - charDiff,\n        );\n      }\n    }\n    const insertedText = nextText.slice(\n      textareaSelection.selectionEnd - charDiff,\n      textareaSelection.selectionEnd,\n    );\n    if (removedText && removedText.length) {\n      if (insertedText.length) {\n        // let's copy some style before deleting.\n        // we want to copy the style before the cursor OR the style at the cursor if selection\n        // is bigger than 0.\n        copiedStyle = this.getSelectionStyles(\n          _selectionStart,\n          _selectionStart + 1,\n          false,\n        );\n        // now duplicate the style one for each inserted text.\n        copiedStyle = insertedText.map(\n          () =>\n            // this return an array of references, but that is fine since we are\n            // copying the style later.\n            copiedStyle![0],\n        );\n      }\n      if (selection) {\n        removeFrom = _selectionStart;\n        removeTo = _selectionEnd;\n      } else if (backDelete) {\n        // detect differences between forwardDelete and backDelete\n        removeFrom = _selectionEnd - removedText.length;\n        removeTo = _selectionEnd;\n      } else {\n        removeFrom = _selectionEnd;\n        removeTo = _selectionEnd + removedText.length;\n      }\n      this.removeStyleFromTo(removeFrom, removeTo);\n    }\n    if (insertedText.length) {\n      const { copyPasteData } = getEnv();\n      if (\n        fromPaste &&\n        insertedText.join('') === copyPasteData.copiedText &&\n        !config.disableStyleCopyPaste\n      ) {\n        copiedStyle = copyPasteData.copiedTextStyle;\n      }\n      this.insertNewStyleBlock(insertedText, _selectionStart, copiedStyle);\n    }\n    updateAndFire();\n  }\n\n  /**\n   * Composition start\n   */\n  onCompositionStart() {\n    this.inCompositionMode = true;\n  }\n\n  /**\n   * Composition end\n   */\n  onCompositionEnd() {\n    this.inCompositionMode = false;\n  }\n\n  onCompositionUpdate({ target }: CompositionEvent) {\n    const { selectionStart, selectionEnd } = target as HTMLTextAreaElement;\n    this.compositionStart = selectionStart;\n    this.compositionEnd = selectionEnd;\n    this.updateTextareaPosition();\n  }\n\n  /**\n   * Copies selected text\n   */\n  copy() {\n    if (this.selectionStart === this.selectionEnd) {\n      //do not cut-copy if no selection\n      return;\n    }\n    const { copyPasteData } = getEnv();\n    copyPasteData.copiedText = this.getSelectedText();\n    if (!config.disableStyleCopyPaste) {\n      copyPasteData.copiedTextStyle = this.getSelectionStyles(\n        this.selectionStart,\n        this.selectionEnd,\n        true,\n      );\n    } else {\n      copyPasteData.copiedTextStyle = undefined;\n    }\n    this._copyDone = true;\n  }\n\n  /**\n   * Pastes text\n   */\n  paste() {\n    this.fromPaste = true;\n  }\n\n  /**\n   * Finds the width in pixels before the cursor on the same line\n   * @private\n   * @param {Number} lineIndex\n   * @param {Number} charIndex\n   * @return {Number} widthBeforeCursor width before cursor\n   */\n  _getWidthBeforeCursor(lineIndex: number, charIndex: number): number {\n    let widthBeforeCursor = this._getLineLeftOffset(lineIndex),\n      bound;\n\n    if (charIndex > 0) {\n      bound = this.__charBounds[lineIndex][charIndex - 1];\n      widthBeforeCursor += bound.left + bound.width;\n    }\n    return widthBeforeCursor;\n  }\n\n  /**\n   * Gets start offset of a selection\n   * @param {KeyboardEvent} e Event object\n   * @param {Boolean} isRight\n   * @return {Number}\n   */\n  getDownCursorOffset(e: KeyboardEvent, isRight: boolean): number {\n    const selectionProp = this._getSelectionForOffset(e, isRight),\n      cursorLocation = this.get2DCursorLocation(selectionProp),\n      lineIndex = cursorLocation.lineIndex;\n    // if on last line, down cursor goes to end of line\n    if (\n      lineIndex === this._textLines.length - 1 ||\n      e.metaKey ||\n      e.keyCode === 34\n    ) {\n      // move to the end of a text\n      return this._text.length - selectionProp;\n    }\n    const charIndex = cursorLocation.charIndex,\n      widthBeforeCursor = this._getWidthBeforeCursor(lineIndex, charIndex),\n      indexOnOtherLine = this._getIndexOnLine(lineIndex + 1, widthBeforeCursor),\n      textAfterCursor = this._textLines[lineIndex].slice(charIndex);\n    return (\n      textAfterCursor.length +\n      indexOnOtherLine +\n      1 +\n      this.missingNewlineOffset(lineIndex)\n    );\n  }\n\n  /**\n   * private\n   * Helps finding if the offset should be counted from Start or End\n   * @param {KeyboardEvent} e Event object\n   * @param {Boolean} isRight\n   * @return {Number}\n   */\n  _getSelectionForOffset(e: KeyboardEvent, isRight: boolean): number {\n    if (e.shiftKey && this.selectionStart !== this.selectionEnd && isRight) {\n      return this.selectionEnd;\n    } else {\n      return this.selectionStart;\n    }\n  }\n\n  /**\n   * @param {KeyboardEvent} e Event object\n   * @param {Boolean} isRight\n   * @return {Number}\n   */\n  getUpCursorOffset(e: KeyboardEvent, isRight: boolean): number {\n    const selectionProp = this._getSelectionForOffset(e, isRight),\n      cursorLocation = this.get2DCursorLocation(selectionProp),\n      lineIndex = cursorLocation.lineIndex;\n    if (lineIndex === 0 || e.metaKey || e.keyCode === 33) {\n      // if on first line, up cursor goes to start of line\n      return -selectionProp;\n    }\n    const charIndex = cursorLocation.charIndex,\n      widthBeforeCursor = this._getWidthBeforeCursor(lineIndex, charIndex),\n      indexOnOtherLine = this._getIndexOnLine(lineIndex - 1, widthBeforeCursor),\n      textBeforeCursor = this._textLines[lineIndex].slice(0, charIndex),\n      missingNewlineOffset = this.missingNewlineOffset(lineIndex - 1);\n    // return a negative offset\n    return (\n      -this._textLines[lineIndex - 1].length +\n      indexOnOtherLine -\n      textBeforeCursor.length +\n      (1 - missingNewlineOffset)\n    );\n  }\n\n  /**\n   * for a given width it founds the matching character.\n   * @private\n   */\n  _getIndexOnLine(lineIndex: number, width: number) {\n    const line = this._textLines[lineIndex],\n      lineLeftOffset = this._getLineLeftOffset(lineIndex);\n    let widthOfCharsOnLine = lineLeftOffset,\n      indexOnLine = 0,\n      charWidth,\n      foundMatch;\n\n    for (let j = 0, jlen = line.length; j < jlen; j++) {\n      charWidth = this.__charBounds[lineIndex][j].width;\n      widthOfCharsOnLine += charWidth;\n      if (widthOfCharsOnLine > width) {\n        foundMatch = true;\n        const leftEdge = widthOfCharsOnLine - charWidth,\n          rightEdge = widthOfCharsOnLine,\n          offsetFromLeftEdge = Math.abs(leftEdge - width),\n          offsetFromRightEdge = Math.abs(rightEdge - width);\n\n        indexOnLine = offsetFromRightEdge < offsetFromLeftEdge ? j : j - 1;\n        break;\n      }\n    }\n\n    // reached end\n    if (!foundMatch) {\n      indexOnLine = line.length - 1;\n    }\n\n    return indexOnLine;\n  }\n\n  /**\n   * Moves cursor down\n   * @param {KeyboardEvent} e Event object\n   */\n  moveCursorDown(e: KeyboardEvent) {\n    if (\n      this.selectionStart >= this._text.length &&\n      this.selectionEnd >= this._text.length\n    ) {\n      return;\n    }\n    this._moveCursorUpOrDown('Down', e);\n  }\n\n  /**\n   * Moves cursor up\n   * @param {KeyboardEvent} e Event object\n   */\n  moveCursorUp(e: KeyboardEvent) {\n    if (this.selectionStart === 0 && this.selectionEnd === 0) {\n      return;\n    }\n    this._moveCursorUpOrDown('Up', e);\n  }\n\n  /**\n   * Moves cursor up or down, fires the events\n   * @param {String} direction 'Up' or 'Down'\n   * @param {KeyboardEvent} e Event object\n   */\n  _moveCursorUpOrDown(direction: 'Up' | 'Down', e: KeyboardEvent) {\n    const offset = this[`get${direction}CursorOffset`](\n      e,\n      this._selectionDirection === RIGHT,\n    );\n    if (e.shiftKey) {\n      this.moveCursorWithShift(offset);\n    } else {\n      this.moveCursorWithoutShift(offset);\n    }\n    if (offset !== 0) {\n      const max = this.text.length;\n      this.selectionStart = capValue(0, this.selectionStart, max);\n      this.selectionEnd = capValue(0, this.selectionEnd, max);\n      // TODO fix: abort and init should be an alternative depending\n      // on selectionStart/End being equal or different\n      this.abortCursorAnimation();\n      this.initDelayedCursor();\n      this._fireSelectionChanged();\n      this._updateTextarea();\n    }\n  }\n\n  /**\n   * Moves cursor with shift\n   * @param {Number} offset\n   */\n  moveCursorWithShift(offset: number) {\n    const newSelection =\n      this._selectionDirection === LEFT\n        ? this.selectionStart + offset\n        : this.selectionEnd + offset;\n    this.setSelectionStartEndWithShift(\n      this.selectionStart,\n      this.selectionEnd,\n      newSelection,\n    );\n    return offset !== 0;\n  }\n\n  /**\n   * Moves cursor up without shift\n   * @param {Number} offset\n   */\n  moveCursorWithoutShift(offset: number) {\n    if (offset < 0) {\n      this.selectionStart += offset;\n      this.selectionEnd = this.selectionStart;\n    } else {\n      this.selectionEnd += offset;\n      this.selectionStart = this.selectionEnd;\n    }\n    return offset !== 0;\n  }\n\n  /**\n   * Moves cursor left\n   * @param {KeyboardEvent} e Event object\n   */\n  moveCursorLeft(e: KeyboardEvent) {\n    if (this.selectionStart === 0 && this.selectionEnd === 0) {\n      return;\n    }\n    this._moveCursorLeftOrRight('Left', e);\n  }\n\n  /**\n   * @private\n   * @return {Boolean} true if a change happened\n   *\n   * @todo refactor not to use method name composition\n   */\n  _move(\n    e: KeyboardEvent,\n    prop: 'selectionStart' | 'selectionEnd',\n    direction: 'Left' | 'Right',\n  ): boolean {\n    let newValue: number | undefined;\n    if (e.altKey) {\n      newValue = this[`findWordBoundary${direction}`](this[prop]);\n    } else if (e.metaKey || e.keyCode === 35 || e.keyCode === 36) {\n      newValue = this[`findLineBoundary${direction}`](this[prop]);\n    } else {\n      this[prop] += direction === 'Left' ? -1 : 1;\n      return true;\n    }\n    if (typeof newValue !== 'undefined' && this[prop] !== newValue) {\n      this[prop] = newValue;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @private\n   */\n  _moveLeft(e: KeyboardEvent, prop: 'selectionStart' | 'selectionEnd') {\n    return this._move(e, prop, 'Left');\n  }\n\n  /**\n   * @private\n   */\n  _moveRight(e: KeyboardEvent, prop: 'selectionStart' | 'selectionEnd') {\n    return this._move(e, prop, 'Right');\n  }\n\n  /**\n   * Moves cursor left without keeping selection\n   * @param {KeyboardEvent} e\n   */\n  moveCursorLeftWithoutShift(e: KeyboardEvent) {\n    let change = true;\n    this._selectionDirection = LEFT;\n\n    // only move cursor when there is no selection,\n    // otherwise we discard it, and leave cursor on same place\n    if (\n      this.selectionEnd === this.selectionStart &&\n      this.selectionStart !== 0\n    ) {\n      change = this._moveLeft(e, 'selectionStart');\n    }\n    this.selectionEnd = this.selectionStart;\n    return change;\n  }\n\n  /**\n   * Moves cursor left while keeping selection\n   * @param {KeyboardEvent} e\n   */\n  moveCursorLeftWithShift(e: KeyboardEvent) {\n    if (\n      this._selectionDirection === RIGHT &&\n      this.selectionStart !== this.selectionEnd\n    ) {\n      return this._moveLeft(e, 'selectionEnd');\n    } else if (this.selectionStart !== 0) {\n      this._selectionDirection = LEFT;\n      return this._moveLeft(e, 'selectionStart');\n    }\n  }\n\n  /**\n   * Moves cursor right\n   * @param {KeyboardEvent} e Event object\n   */\n  moveCursorRight(e: KeyboardEvent) {\n    if (\n      this.selectionStart >= this._text.length &&\n      this.selectionEnd >= this._text.length\n    ) {\n      return;\n    }\n    this._moveCursorLeftOrRight('Right', e);\n  }\n\n  /**\n   * Moves cursor right or Left, fires event\n   * @param {String} direction 'Left', 'Right'\n   * @param {KeyboardEvent} e Event object\n   */\n  _moveCursorLeftOrRight(direction: 'Left' | 'Right', e: KeyboardEvent) {\n    const actionName = `moveCursor${direction}${\n      e.shiftKey ? 'WithShift' : 'WithoutShift'\n    }` as const;\n    this._currentCursorOpacity = 1;\n    if (this[actionName](e)) {\n      // TODO fix: abort and init should be an alternative depending\n      // on selectionStart/End being equal or different\n      this.abortCursorAnimation();\n      this.initDelayedCursor();\n      this._fireSelectionChanged();\n      this._updateTextarea();\n    }\n  }\n\n  /**\n   * Moves cursor right while keeping selection\n   * @param {KeyboardEvent} e\n   */\n  moveCursorRightWithShift(e: KeyboardEvent) {\n    if (\n      this._selectionDirection === LEFT &&\n      this.selectionStart !== this.selectionEnd\n    ) {\n      return this._moveRight(e, 'selectionStart');\n    } else if (this.selectionEnd !== this._text.length) {\n      this._selectionDirection = RIGHT;\n      return this._moveRight(e, 'selectionEnd');\n    }\n  }\n\n  /**\n   * Moves cursor right without keeping selection\n   * @param {KeyboardEvent} e Event object\n   */\n  moveCursorRightWithoutShift(e: KeyboardEvent) {\n    let changed = true;\n    this._selectionDirection = RIGHT;\n\n    if (this.selectionStart === this.selectionEnd) {\n      changed = this._moveRight(e, 'selectionStart');\n      this.selectionEnd = this.selectionStart;\n    } else {\n      this.selectionStart = this.selectionEnd;\n    }\n    return changed;\n  }\n}\n"],"names":["ITextKeyBehavior","ITextBehavior","initHiddenTextarea","doc","this","canvas","getDocumentFromElement","getElement","getFabricDocument","textarea","createElement","Object","entries","autocapitalize","autocorrect","autocomplete","spellcheck","wrap","map","_ref","attribute","value","setAttribute","top","left","fontSize","_calcTextareaPosition","style","cssText","hiddenTextareaContainer","body","appendChild","blur","keydown","keyup","input","copy","cut","paste","compositionstart","compositionupdate","compositionend","_ref2","eventName","handler","addEventListener","bind","hiddenTextarea","abortCursorAnimation","onKeyDown","e","isEditing","keyMap","direction","keysMapRtl","keysMap","keyCode","ctrlKeysMapDown","ctrlKey","metaKey","stopImmediatePropagation","preventDefault","inCompositionMode","clearContextTop","renderCursorOrSelection","requestRenderAll","onKeyUp","_copyDone","ctrlKeysMapUp","onInput","fromPaste","selectionStart","selectionEnd","stopPropagation","updateAndFire","updateFromTextArea","fire","CHANGED","target","styles","nextText","_splitTextIntoLines","graphemeText","charCount","_text","length","nextCharCount","_selectionStart","_selectionEnd","selection","copiedStyle","removedText","removeFrom","removeTo","charDiff","textareaSelection","fromStringToGraphemeSelection","backDelete","slice","insertedText","getSelectionStyles","removeStyleFromTo","copyPasteData","getEnv","join","copiedText","config","disableStyleCopyPaste","copiedTextStyle","insertNewStyleBlock","onCompositionStart","onCompositionEnd","onCompositionUpdate","_ref3","compositionStart","compositionEnd","updateTextareaPosition","getSelectedText","undefined","_getWidthBeforeCursor","lineIndex","charIndex","bound","widthBeforeCursor","_getLineLeftOffset","__charBounds","width","getDownCursorOffset","isRight","selectionProp","_getSelectionForOffset","cursorLocation","get2DCursorLocation","_textLines","indexOnOtherLine","_getIndexOnLine","missingNewlineOffset","shiftKey","getUpCursorOffset","textBeforeCursor","line","charWidth","foundMatch","widthOfCharsOnLine","indexOnLine","j","jlen","leftEdge","rightEdge","offsetFromLeftEdge","Math","abs","moveCursorDown","_moveCursorUpOrDown","moveCursorUp","offset","_selectionDirection","RIGHT","moveCursorWithShift","moveCursorWithoutShift","max","text","capValue","initDelayedCursor","_fireSelectionChanged","_updateTextarea","newSelection","LEFT","setSelectionStartEndWithShift","moveCursorLeft","_moveCursorLeftOrRight","_move","prop","newValue","altKey","_moveLeft","_moveRight","moveCursorLeftWithoutShift","change","moveCursorLeftWithShift","moveCursorRight","actionName","_currentCursorOpacity","moveCursorRightWithShift","moveCursorRightWithoutShift","changed"],"mappings":"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"}