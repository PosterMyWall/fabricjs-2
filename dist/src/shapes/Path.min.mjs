import{defineProperty as t}from"../../_virtual/_rollupPluginBabelHelpers.min.mjs";import{config as e}from"../config.min.mjs";import{SHARED_ATTRIBUTES as s}from"../parser/attributes.min.mjs";import{parseAttributes as r}from"../parser/parseAttributes.min.mjs";import{Point as i}from"../Point.min.mjs";import{makeBoundingBoxFromPoints as o}from"../util/misc/boundingBoxFromPoints.min.mjs";import{toFixed as a}from"../util/misc/toFixed.min.mjs";import{makePathSimpler as n,parsePath as h,joinPath as m,getBoundsOfCurve as c}from"../util/path/index.min.mjs";import{classRegistry as p}from"../ClassRegistry.min.mjs";import{FabricObject as f}from"./Object/FabricObject.min.mjs";import{LEFT as l,TOP as u,CENTER as d}from"../constants.min.mjs";import{cacheProperties as _}from"./Object/defaultValues.min.mjs";class b extends f{constructor(t){let{path:e,left:s,top:r,...i}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};super(),Object.assign(this,b.ownDefaults),this.setOptions(i),this._setPath(t||[],!0),"number"==typeof s&&this.set(l,s),"number"==typeof r&&this.set(u,r)}_setPath(t,e){this.path=n(Array.isArray(t)?t:h(t)),this.setBoundingBox(e)}_findCenterFromElement(){const t=this._calcBoundsFromPath();return new i(t.left+t.width/2,t.top+t.height/2)}_renderPathCommands(t){const e=-this.pathOffset.x,s=-this.pathOffset.y;t.beginPath();for(const r of this.path)switch(r[0]){case"L":t.lineTo(r[1]+e,r[2]+s);break;case"M":t.moveTo(r[1]+e,r[2]+s);break;case"C":t.bezierCurveTo(r[1]+e,r[2]+s,r[3]+e,r[4]+s,r[5]+e,r[6]+s);break;case"Q":t.quadraticCurveTo(r[1]+e,r[2]+s,r[3]+e,r[4]+s);break;case"Z":t.closePath()}}_render(t){this._renderPathCommands(t),this._renderPaintInOrder(t)}toString(){return`#<Path (${this.complexity()}): { "top": ${this.top}, "left": ${this.left} }>`}toObject(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return{...super.toObject(t),path:this.path.map((t=>t.slice()))}}toDatalessObject(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];const e=this.toObject(t);return this.sourcePath&&(delete e.path,e.sourcePath=this.sourcePath),e}_toSVG(){return["<path ","COMMON_PARTS",`d="${m(this.path,e.NUM_FRACTION_DIGITS)}" stroke-linecap="round" />\n`]}_getOffsetTransform(){const t=e.NUM_FRACTION_DIGITS;return` translate(${a(-this.pathOffset.x,t)}, ${a(-this.pathOffset.y,t)})`}toClipPathSVG(t){const e=this._getOffsetTransform();return"\t"+this._createBaseClipPathSVGMarkup(this._toSVG(),{reviver:t,additionalTransform:e})}toSVG(t){const e=this._getOffsetTransform();return this._createBaseSVGMarkup(this._toSVG(),{reviver:t,additionalTransform:e})}complexity(){return this.path.length}setDimensions(){this.setBoundingBox()}setBoundingBox(t){const{width:e,height:s,pathOffset:r}=this._calcDimensions();this.set({width:e,height:s,pathOffset:r}),t&&this.setPositionByOrigin(r,d,d)}_calcBoundsFromPath(){const t=[];let e=0,s=0,r=0,i=0;for(const o of this.path)switch(o[0]){case"L":r=o[1],i=o[2],t.push({x:e,y:s},{x:r,y:i});break;case"M":r=o[1],i=o[2],e=r,s=i;break;case"C":t.push(...c(r,i,o[1],o[2],o[3],o[4],o[5],o[6])),r=o[5],i=o[6];break;case"Q":t.push(...c(r,i,o[1],o[2],o[1],o[2],o[3],o[4])),r=o[3],i=o[4];break;case"Z":r=e,i=s}return o(t)}_calcDimensions(){const t=this._calcBoundsFromPath();return{...t,pathOffset:new i(t.left+t.width/2,t.top+t.height/2)}}static fromObject(t){return this._fromObject(t,{extraParam:"path"})}static async fromElement(t,e,s){const{d:i,...o}=r(t,this.ATTRIBUTE_NAMES,s);return new this(i,{...o,...e,left:void 0,top:void 0})}}t(b,"type","Path"),t(b,"cacheProperties",[..._,"path","fillRule"]),t(b,"ATTRIBUTE_NAMES",[...s,"d"]),p.setClass(b),p.setSVGClass(b);export{b as Path};
//# sourceMappingURL=Path.min.mjs.map
