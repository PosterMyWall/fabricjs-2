{"version":3,"file":"Group.min.mjs","sources":["../../../src/shapes/Group.ts"],"sourcesContent":["import type {\n  CollectionEvents,\n  ObjectEvents,\n  TPointerEvent,\n} from '../EventTypeDefs';\nimport { createCollectionMixin } from '../Collection';\nimport type {\n  TClassProperties,\n  TSVGReviver,\n  TOptions,\n  Abortable,\n  TCacheCanvasDimensions,\n} from '../typedefs';\nimport {\n  invertTransform,\n  multiplyTransformMatrices,\n} from '../util/misc/matrix';\nimport {\n  enlivenObjectEnlivables,\n  enlivenObjects,\n} from '../util/misc/objectEnlive';\nimport { applyTransformToObject } from '../util/misc/objectTransforms';\nimport { FabricObject } from './Object/FabricObject';\nimport { Rect } from './Rect';\nimport { classRegistry } from '../ClassRegistry';\nimport type { FabricObjectProps, SerializedObjectProps } from './Object/types';\nimport { log } from '../util/internals/console';\nimport type {\n  ImperativeLayoutOptions,\n  LayoutBeforeEvent,\n  LayoutAfterEvent,\n} from '../LayoutManager/types';\nimport { LayoutManager } from '../LayoutManager/LayoutManager';\nimport {\n  LAYOUT_TYPE_ADDED,\n  LAYOUT_TYPE_IMPERATIVE,\n  LAYOUT_TYPE_INITIALIZATION,\n  LAYOUT_TYPE_REMOVED,\n} from '../LayoutManager/constants';\nimport type { SerializedLayoutManager } from '../LayoutManager/LayoutManager';\nimport type { FitContentLayout } from '../LayoutManager';\nimport type { DrawContext } from './Object/Object';\nimport type { Table } from './Table';\n\n/**\n * This class handles the specific case of creating a group using {@link Group#fromObject} and is not meant to be used in any other case.\n * We could have used a boolean in the constructor, as we did previously, but we think the boolean\n * would stay in the group's constructor interface and create confusion, therefore it was removed.\n * This layout manager doesn't do anything and therefore keeps the exact layout the group had when {@link Group#toObject} was called.\n */\nclass NoopLayoutManager extends LayoutManager {\n  performLayout() {}\n}\n\nexport interface GroupEvents extends ObjectEvents, CollectionEvents {\n  'layout:before': LayoutBeforeEvent;\n  'layout:after': LayoutAfterEvent;\n}\n\nexport interface GroupOwnProps {\n  subTargetCheck: boolean;\n  interactive: boolean;\n  caterCacheForTextChildren: boolean;\n  selected: boolean;\n  useSelectedFlag: boolean;\n}\n\nexport interface SerializedGroupProps\n  extends SerializedObjectProps,\n    GroupOwnProps {\n  objects: SerializedObjectProps[];\n  layoutManager: SerializedLayoutManager;\n}\n\nexport interface GroupProps extends FabricObjectProps, GroupOwnProps {\n  layoutManager: LayoutManager;\n}\n\nexport const groupDefaultValues: Partial<TClassProperties<Group>> = {\n  strokeWidth: 0,\n  subTargetCheck: false,\n  caterCacheForTextChildren: false,\n  selected: false,\n  useSelectedFlag: false,\n  interactive: false,\n};\n\n/**\n * @fires object:added\n * @fires object:removed\n * @fires layout:before\n * @fires layout:after\n */\nexport class Group\n  extends createCollectionMixin(\n    FabricObject<GroupProps, SerializedGroupProps, GroupEvents>,\n  )\n  implements GroupProps\n{\n  /**\n   * Used to optimize performance\n   * set to `false` if you don't need contained objects to be targets of events\n   * @default\n   * @type boolean\n   */\n  declare subTargetCheck: boolean;\n\n  /**\n   * *PMW property added*\n   * Whether to cater to the text children objects for caching.\n   */\n  declare caterCacheForTextChildren: boolean;\n\n  /**\n   * *PMW property added*\n   * Whether the object is currently selected.\n   * This is being used in GraphicItemSlideshowMediator to handle text editing.\n   * The editing mode is entered on single click when the item is selected. So we use this flag to determine if the item is selected.\n   */\n  declare selected: boolean;\n\n  /**\n   * *PMW property added*\n   * Whether the PMW added selected flag should be used.\n   */\n  declare useSelectedFlag: boolean;\n\n  /**\n   * Used to allow targeting of object inside groups.\n   * set to true if you want to select an object inside a group.\\\n   * **REQUIRES** `subTargetCheck` set to true\n   * This will be not removed but slowly replaced with a method setInteractive\n   * that will take care of enabling subTargetCheck and necessary object events.\n   * There is too much attached to group interactivity to just be evaluated by a\n   * boolean in the code\n   * @default\n   * @deprecated\n   * @type boolean\n   */\n  declare interactive: boolean;\n\n  declare layoutManager: LayoutManager;\n\n  /**\n   * Used internally to optimize performance\n   * Once an object is selected, instance is rendered without the selected object.\n   * This way instance is cached only once for the entire interaction with the selected object.\n   * @private\n   */\n  protected _activeObjects: FabricObject[] = [];\n\n  static type = 'Group';\n\n  static ownDefaults: Record<string, any> = groupDefaultValues;\n  private __objectSelectionTracker: (ev: ObjectEvents['selected']) => void;\n  private __objectSelectionDisposer: (ev: ObjectEvents['deselected']) => void;\n\n  static getDefaults(): Record<string, any> {\n    return {\n      ...super.getDefaults(),\n      ...Group.ownDefaults,\n    };\n  }\n\n  /**\n   * Constructor\n   *\n   * @param {FabricObject[]} [objects] instance objects\n   * @param {Object} [options] Options object\n   */\n  constructor(objects: FabricObject[] = [], options: Partial<GroupProps> = {}) {\n    super();\n    Object.assign(this, Group.ownDefaults);\n    this.setOptions(options);\n    this.groupInit(objects, options);\n  }\n\n  /**\n   * *PMW function added*\n   * Called everytime a group object is deselected. The useSelectedFlag is used and only true when the group object is slideshow item. See docs of 'selected' property.\n   */\n  onDeselect(options?: { e?: TPointerEvent; object?: any }): boolean {\n    if (this.useSelectedFlag) {\n      this.selected = false;\n    }\n    return super.onDeselect(options);\n  }\n\n  /**\n   * *PMW* function added\n   * Expands cache dimensions to cater to any text children objects present inside the group.\n   * This is to prevent any part of the font rendering outside the selector box getting cut.\n   * @private\n   * @return {Object}.x width of object to be cached\n   * @return {Object}.y height of object to be cached\n   * @return {Object}.width width of canvas\n   * @return {Object}.height height of canvas\n   * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache\n   * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache\n   */\n  _getCacheCanvasDimensions(): TCacheCanvasDimensions {\n    if (this.caterCacheForTextChildren) {\n      const dims = super._getCacheCanvasDimensions();\n      let widthToAdd = 0;\n      let heightToAdd = 0;\n      const maxFontSize = this._getMaxExpandedFontSizeFromTextChildren();\n\n      if (maxFontSize > 0) {\n        widthToAdd = maxFontSize * dims.zoomX;\n        heightToAdd = maxFontSize * dims.zoomY;\n      }\n\n      dims.width += widthToAdd;\n      dims.height += heightToAdd;\n      return dims;\n    }\n    return super._getCacheCanvasDimensions();\n  }\n\n  /**\n   * *PMW funtion added*\n   * Scans itself for children text items and returns the max font size from them. Multiplies the expansion factor with the fontsize if it exists for the font family. If there's no text, returns 0.\n   * @private\n   */\n  _getMaxExpandedFontSizeFromTextChildren() {\n    const groupObjects = this.getObjects();\n    let maxFontSize = 0;\n\n    for (const groupObject of groupObjects) {\n      if ('fontSize' in groupObject) {\n        const fontSize = groupObject.fontSize as number;\n        if (fontSize > maxFontSize) {\n          // @ts-ignore\n          maxFontSize = fontSize * groupObject.cacheExpansionFactor;\n        }\n      } else if (groupObject instanceof Group) {\n        const maxFontSizeInGroup =\n          groupObject._getMaxExpandedFontSizeFromTextChildren();\n        if (maxFontSizeInGroup > maxFontSize) {\n          maxFontSize = maxFontSizeInGroup;\n        }\n      }\n    }\n    return maxFontSize;\n  }\n\n  /**\n   * Shared code between group and active selection\n   * Meant to be used by the constructor.\n   */\n  protected groupInit(\n    objects: FabricObject[],\n    options: {\n      layoutManager?: LayoutManager;\n      top?: number;\n      left?: number;\n    },\n  ) {\n    this._objects = [...objects]; // Avoid unwanted mutations of Collection to affect the caller\n\n    this.__objectSelectionTracker = this.__objectSelectionMonitor.bind(\n      this,\n      true,\n    );\n    this.__objectSelectionDisposer = this.__objectSelectionMonitor.bind(\n      this,\n      false,\n    );\n\n    this.forEachObject((object) => {\n      this.enterGroup(object, false);\n    });\n\n    // perform initial layout\n    this.layoutManager = options.layoutManager ?? new LayoutManager();\n    this.layoutManager.performLayout({\n      type: LAYOUT_TYPE_INITIALIZATION,\n      target: this,\n      targets: [...objects],\n      // @TODO remove this concept from the layout manager.\n      // Layout manager will calculate the correct position,\n      // group options can override it later.\n      x: options.left,\n      y: options.top,\n    });\n  }\n\n  /**\n   * Checks if object can enter group and logs relevant warnings\n   * @private\n   * @param {FabricObject} object\n   * @returns\n   */\n  canEnterGroup(object: FabricObject) {\n    if (object === this || this.isDescendantOf(object)) {\n      //  prevent circular object tree\n      log(\n        'error',\n        'Group: circular object trees are not supported, this call has no effect',\n      );\n      return false;\n    } else if (this._objects.indexOf(object) !== -1) {\n      // is already in the objects array\n      log(\n        'error',\n        'Group: duplicate objects are not supported inside group, this call has no effect',\n      );\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Override this method to enhance performance (for groups with a lot of objects).\n   * If Overriding, be sure not pass illegal objects to group - it will break your app.\n   * @private\n   */\n  protected _filterObjectsBeforeEnteringGroup(objects: FabricObject[]) {\n    return objects.filter((object, index, array) => {\n      // can enter AND is the first occurrence of the object in the passed args (to prevent adding duplicates)\n      return this.canEnterGroup(object) && array.indexOf(object) === index;\n    });\n  }\n\n  /**\n   * Add objects\n   * @param {...FabricObject[]} objects\n   */\n  add(...objects: FabricObject[]) {\n    const allowedObjects = this._filterObjectsBeforeEnteringGroup(objects);\n    const size = super.add(...allowedObjects);\n    this._onAfterObjectsChange(LAYOUT_TYPE_ADDED, allowedObjects);\n    return size;\n  }\n\n  /**\n   * Inserts an object into collection at specified index\n   * @param {FabricObject[]} objects Object to insert\n   * @param {Number} index Index to insert object at\n   */\n  insertAt(index: number, ...objects: FabricObject[]) {\n    const allowedObjects = this._filterObjectsBeforeEnteringGroup(objects);\n    const size = super.insertAt(index, ...allowedObjects);\n    this._onAfterObjectsChange(LAYOUT_TYPE_ADDED, allowedObjects);\n    return size;\n  }\n\n  /**\n   * Remove objects\n   * @param {...FabricObject[]} objects\n   * @returns {FabricObject[]} removed objects\n   */\n  remove(...objects: FabricObject[]) {\n    const removed = super.remove(...objects);\n    this._onAfterObjectsChange(LAYOUT_TYPE_REMOVED, removed);\n    return removed;\n  }\n\n  _onObjectAdded(object: FabricObject) {\n    this.enterGroup(object, true);\n    this.fire('object:added', { target: object });\n    object.fire('added', { target: this });\n  }\n\n  /**\n   * @private\n   * @param {FabricObject} object\n   * @param {boolean} [removeParentTransform] true if object should exit group without applying group's transform to it\n   */\n  _onObjectRemoved(object: FabricObject, removeParentTransform?: boolean) {\n    this.exitGroup(object, removeParentTransform);\n    this.fire('object:removed', { target: object });\n    object.fire('removed', { target: this });\n  }\n\n  /**\n   * @private\n   * @param {'added'|'removed'} type\n   * @param {FabricObject[]} targets\n   */\n  _onAfterObjectsChange(type: 'added' | 'removed', targets: FabricObject[]) {\n    this.layoutManager.performLayout({\n      type,\n      targets,\n      target: this,\n    });\n  }\n\n  _onStackOrderChanged() {\n    this._set('dirty', true);\n  }\n\n  /**\n   * @private\n   * @param {string} key\n   * @param {*} value\n   */\n  _set(key: string, value: any) {\n    const prev = this[key as keyof this];\n    super._set(key, value);\n    if (key === 'canvas' && prev !== value) {\n      (this._objects || []).forEach((object) => {\n        object._set(key, value);\n      });\n    }\n    return this;\n  }\n\n  /**\n   * @private\n   */\n  _shouldSetNestedCoords() {\n    return this.subTargetCheck;\n  }\n\n  /**\n   * Remove all objects\n   * @returns {FabricObject[]} removed objects\n   */\n  removeAll() {\n    this._activeObjects = [];\n    return this.remove(...this._objects);\n  }\n\n  /**\n   * keeps track of the selected objects\n   * @private\n   */\n  __objectSelectionMonitor<T extends boolean>(\n    selected: T,\n    {\n      target: object,\n    }: ObjectEvents[T extends true ? 'selected' : 'deselected'],\n  ) {\n    const activeObjects = this._activeObjects;\n    if (selected) {\n      activeObjects.push(object);\n      this._set('dirty', true);\n    } else if (activeObjects.length > 0) {\n      const index = activeObjects.indexOf(object);\n      if (index > -1) {\n        activeObjects.splice(index, 1);\n        this._set('dirty', true);\n      }\n    }\n  }\n\n  /**\n   * @private\n   * @param {boolean} watch\n   * @param {FabricObject} object\n   */\n  _watchObject(watch: boolean, object: FabricObject) {\n    //  make sure we listen only once\n    watch && this._watchObject(false, object);\n    if (watch) {\n      object.on('selected', this.__objectSelectionTracker);\n      object.on('deselected', this.__objectSelectionDisposer);\n    } else {\n      object.off('selected', this.__objectSelectionTracker);\n      object.off('deselected', this.__objectSelectionDisposer);\n    }\n  }\n\n  /**\n   * @private\n   * @param {FabricObject} object\n   * @param {boolean} [removeParentTransform] true if object is in canvas coordinate plane\n   */\n  enterGroup(object: FabricObject, removeParentTransform?: boolean) {\n    object.group && object.group.remove(object);\n    object._set('parent', this);\n    this._enterGroup(object, removeParentTransform);\n  }\n\n  /**\n   * @private\n   * @param {FabricObject} object\n   * @param {boolean} [removeParentTransform] true if object is in canvas coordinate plane\n   */\n  _enterGroup(object: FabricObject, removeParentTransform?: boolean) {\n    if (removeParentTransform) {\n      // can this be converted to utils (sendObjectToPlane)?\n      applyTransformToObject(\n        object,\n        multiplyTransformMatrices(\n          invertTransform(this.calcTransformMatrix()),\n          object.calcTransformMatrix(),\n        ),\n      );\n    }\n    this._shouldSetNestedCoords() && object.setCoords();\n    object._set('group', this);\n    object._set('canvas', this.canvas);\n    this._watchObject(true, object);\n    const activeObject =\n      this.canvas &&\n      this.canvas.getActiveObject &&\n      this.canvas.getActiveObject();\n    // if we are adding the activeObject in a group\n    if (\n      activeObject &&\n      (activeObject === object || object.isDescendantOf(activeObject))\n    ) {\n      this._activeObjects.push(object);\n    }\n  }\n\n  /**\n   * @private\n   * @param {FabricObject} object\n   * @param {boolean} [removeParentTransform] true if object should exit group without applying group's transform to it\n   */\n  exitGroup(object: FabricObject, removeParentTransform?: boolean) {\n    this._exitGroup(object, removeParentTransform);\n    object._set('parent', undefined);\n    object._set('canvas', undefined);\n  }\n\n  /**\n   * Executes the inner fabric logic of exiting a group.\n   * - Stop watching the object\n   * - Remove the object from the optimization map this._activeObjects\n   * - unset the group property of the object\n   * @protected\n   * @param {FabricObject} object\n   * @param {boolean} [removeParentTransform] true if object should exit group without applying group's transform to it\n   */\n  _exitGroup(object: FabricObject, removeParentTransform?: boolean) {\n    object._set('group', undefined);\n    if (!removeParentTransform) {\n      applyTransformToObject(\n        object,\n        multiplyTransformMatrices(\n          this.calcTransformMatrix(),\n          object.calcTransformMatrix(),\n        ),\n      );\n      object.setCoords();\n    }\n    this._watchObject(false, object);\n    const index =\n      this._activeObjects.length > 0 ? this._activeObjects.indexOf(object) : -1;\n    if (index > -1) {\n      this._activeObjects.splice(index, 1);\n    }\n  }\n\n  /**\n   * Decide if the group should cache or not. Create its own cache level\n   * needsItsOwnCache should be used when the object drawing method requires\n   * a cache step.\n   * Generally you do not cache objects in groups because the group is already cached.\n   * @return {Boolean}\n   */\n  shouldCache() {\n    const ownCache = FabricObject.prototype.shouldCache.call(this);\n    if (ownCache) {\n      for (let i = 0; i < this._objects.length; i++) {\n        if (this._objects[i].willDrawShadow()) {\n          this.ownCaching = false;\n          return false;\n        }\n      }\n    }\n    return ownCache;\n  }\n\n  /**\n   * Check if this object or a child object will cast a shadow\n   * @return {Boolean}\n   */\n  willDrawShadow() {\n    if (super.willDrawShadow()) {\n      return true;\n    }\n    for (let i = 0; i < this._objects.length; i++) {\n      if (this._objects[i].willDrawShadow()) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  isGroup(): this is Group {\n    return true;\n  }\n\n  /**\n   * Check if instance or its group are caching, recursively up\n   * @return {Boolean}\n   */\n  isOnACache(): boolean {\n    return this.ownCaching || (!!this.parent && this.parent.isOnACache());\n  }\n\n  /**\n   * Execute the drawing operation for an object on a specified context\n   * @param {CanvasRenderingContext2D} ctx Context to render on\n   */\n  drawObject(\n    ctx: CanvasRenderingContext2D,\n    forClipping: boolean | undefined,\n    context: DrawContext,\n  ) {\n    this._renderBackground(ctx);\n    for (let i = 0; i < this._objects.length; i++) {\n      const obj = this._objects[i];\n      // TODO: handle rendering edge case somehow\n      if (this.canvas?.preserveObjectStacking && obj.group !== this) {\n        ctx.save();\n        ctx.transform(...invertTransform(this.calcTransformMatrix()));\n        obj.render(ctx);\n        ctx.restore();\n      } else if (obj.group === this) {\n        obj.render(ctx);\n      }\n    }\n    this._drawClipPath(ctx, this.clipPath, context);\n  }\n\n  /**\n   * @override\n   * @return {Boolean}\n   */\n  setCoords() {\n    super.setCoords();\n    this._shouldSetNestedCoords() &&\n    this.forEachObject((object) => object.setCoords());\n  }\n\n  triggerLayout(options: ImperativeLayoutOptions = {}) {\n    this.layoutManager.performLayout({\n      target: this,\n      type: LAYOUT_TYPE_IMPERATIVE,\n      ...options,\n    });\n  }\n\n  /**\n   * Renders instance on a given context\n   * @param {CanvasRenderingContext2D} ctx context to render instance on\n   */\n  render(ctx: CanvasRenderingContext2D) {\n    this._transformDone = true;\n    super.render(ctx);\n    this._transformDone = false;\n  }\n\n  public isTable(): this is Table {\n    return false;\n  }\n\n  /**\n   *\n   * @private\n   * @param {'toObject'|'toDatalessObject'} [method]\n   * @param {string[]} [propertiesToInclude] Any properties that you might want to additionally include in the output\n   * @returns {FabricObject[]} serialized objects\n   */\n  __serializeObjects(\n    method: 'toObject' | 'toDatalessObject',\n    propertiesToInclude?: string[],\n  ) {\n    const _includeDefaultValues = this.includeDefaultValues;\n    return this._objects\n      .filter(function (obj) {\n        return !obj.excludeFromExport;\n      })\n      .map(function (obj) {\n        const originalDefaults = obj.includeDefaultValues;\n        obj.includeDefaultValues = _includeDefaultValues;\n        const data = obj[method || 'toObject'](propertiesToInclude);\n        obj.includeDefaultValues = originalDefaults;\n        // delete data.version;\n        return data;\n      });\n  }\n\n  /**\n   * Returns object representation of an instance\n   * @param {string[]} [propertiesToInclude] Any properties that you might want to additionally include in the output\n   * @return {Object} object representation of an instance\n   */\n  toObject<\n    T extends Omit<\n      GroupProps & TClassProperties<this>,\n      keyof SerializedGroupProps\n    >,\n    K extends keyof T = never,\n  >(propertiesToInclude: K[] = []): Pick<T, K> & SerializedGroupProps {\n    const layoutManager = this.layoutManager.toObject();\n\n    return {\n      ...super.toObject([\n        'subTargetCheck',\n        'interactive',\n        ...propertiesToInclude,\n      ]),\n      ...(layoutManager.strategy !== 'fit-content' || this.includeDefaultValues\n        ? { layoutManager }\n        : {}),\n      objects: this.__serializeObjects(\n        'toObject',\n        propertiesToInclude as string[],\n      ),\n    };\n  }\n\n  toString() {\n    return `#<Group: (${this.complexity()})>`;\n  }\n\n  dispose() {\n    this.layoutManager.unsubscribeTargets({\n      targets: this.getObjects(),\n      target: this,\n    });\n    this._activeObjects = [];\n    this.forEachObject((object) => {\n      this._watchObject(false, object);\n      object.dispose();\n    });\n    super.dispose();\n  }\n\n  /**\n   * @private\n   */\n  _createSVGBgRect(reviver?: TSVGReviver) {\n    if (!this.backgroundColor) {\n      return '';\n    }\n    const fillStroke = Rect.prototype._toSVG.call(this);\n    const commons = fillStroke.indexOf('COMMON_PARTS');\n    fillStroke[commons] = 'for=\"group\" ';\n    const markup = fillStroke.join('');\n    return reviver ? reviver(markup) : markup;\n  }\n\n  /**\n   * Returns svg representation of an instance\n   * @param {TSVGReviver} [reviver] Method for further parsing of svg representation.\n   * @return {String} svg representation of an instance\n   */\n  _toSVG(reviver?: TSVGReviver) {\n    const svgString = ['<g ', 'COMMON_PARTS', ' >\\n'];\n    const bg = this._createSVGBgRect(reviver);\n    bg && svgString.push('\\t\\t', bg);\n    for (let i = 0; i < this._objects.length; i++) {\n      svgString.push('\\t\\t', this._objects[i].toSVG(reviver));\n    }\n    svgString.push('</g>\\n');\n    return svgString;\n  }\n\n  /**\n   * Returns styles-string for svg-export, specific version for group\n   * @return {String}\n   */\n  getSvgStyles(): string {\n    const opacity =\n        typeof this.opacity !== 'undefined' && this.opacity !== 1\n          ? `opacity: ${this.opacity};`\n          : '',\n      visibility = this.visible ? '' : ' visibility: hidden;';\n    return [opacity, this.getSvgFilter(), visibility].join('');\n  }\n\n  /**\n   * Returns svg clipPath representation of an instance\n   * @param {Function} [reviver] Method for further parsing of svg representation.\n   * @return {String} svg representation of an instance\n   */\n  toClipPathSVG(reviver?: TSVGReviver): string {\n    const svgString = [];\n    const bg = this._createSVGBgRect(reviver);\n    bg && svgString.push('\\t', bg);\n    for (let i = 0; i < this._objects.length; i++) {\n      svgString.push('\\t', this._objects[i].toClipPathSVG(reviver));\n    }\n    return this._createBaseClipPathSVGMarkup(svgString, {\n      reviver,\n    });\n  }\n\n  /**\n   * *PMW*\n   * Aligns the items in the group horizontally.\n   * @param {String} type Must be either 'left', 'right' or 'center'\n   */\n  horizontalAlignment(type: 'left' | 'right' | 'center'): void {\n    const groupWidth = this.width,\n      objects = this._objects,\n      padding = this.padding;\n    let i = 0,\n      corners,\n      tl,\n      offsetX;\n\n    switch (type) {\n      case 'left':\n        for (i = 0; i < objects.length; i++) {\n          corners = objects[i].getCornerPoints(objects[i].getCenterPoint());\n          tl = corners.tl.x;\n          const minX = Math.min(tl, corners.tr.x, corners.bl.x, corners.br.x);\n          offsetX = minX < tl ? tl - minX : 0;\n          objects[i].set('left', -groupWidth / 2 + padding + offsetX);\n        }\n        break;\n      case 'right':\n        for (i = 0; i < objects.length; i++) {\n          corners = objects[i].getCornerPoints(objects[i].getCenterPoint());\n          tl = corners.tl.x;\n          const maxX = Math.max(tl, corners.tr.x, corners.bl.x, corners.br.x);\n          offsetX = maxX > tl ? maxX - tl : 0;\n          objects[i].set('left', groupWidth / 2 - offsetX - padding);\n        }\n        break;\n      case 'center':\n        for (i = 0; i < objects.length; i++) {\n          corners = objects[i].getCornerPoints({\n            x: 0,\n            y: objects[i].top,\n          });\n          objects[i].set('left', corners.tl.x);\n        }\n        break;\n      default:\n        return;\n    }\n    this.canvas?.fire('object:modified', { target: this });\n  }\n\n  /**\n   * *PMW* Aligns the items in the group vertically.\n   * @param {String} type Must be either 'top', 'bottom' or 'center'\n   */\n  verticalAlignment(type: 'top' | 'bottom' | 'center') {\n    const groupHeight = this.height,\n      objects = this._objects,\n      padding = this.padding;\n    let i = 0,\n      corners,\n      tl,\n      offsetY;\n\n    switch (type) {\n      case 'top':\n        for (i = 0; i < objects.length; i++) {\n          corners = objects[i].getCornerPoints(objects[i].getCenterPoint());\n          tl = corners.tl.y;\n          const minY = Math.min(tl, corners.tr.y, corners.bl.y, corners.br.y);\n          offsetY = minY < tl ? tl - minY : 0;\n          objects[i].set('top', -groupHeight / 2 + padding + offsetY);\n        }\n        break;\n      case 'bottom':\n        for (i = 0; i < objects.length; i++) {\n          corners = objects[i].getCornerPoints(objects[i].getCenterPoint());\n          tl = corners.tl.y;\n          const maxY = Math.max(tl, corners.tr.y, corners.bl.y, corners.br.y);\n          offsetY = maxY > tl ? maxY - tl : 0;\n          objects[i].set('top', groupHeight / 2 - padding - offsetY);\n        }\n        break;\n      case 'center':\n        for (i = 0; i < objects.length; i++) {\n          corners = objects[i].getCornerPoints({\n            x: objects[i].left,\n            y: 0,\n          });\n          objects[i].set('top', corners.tl.y);\n        }\n        break;\n      default:\n        return;\n    }\n    this.canvas?.fire('object:modified', { target: this });\n  }\n\n  /**\n   * @todo support loading from svg\n   * @private\n   * @static\n   * @memberOf Group\n   * @param {Object} object Object to create a group from\n   * @returns {Promise<Group>}\n   */\n  static fromObject<T extends TOptions<SerializedGroupProps>>(\n    { type, objects = [], layoutManager, ...options }: T,\n    abortable?: Abortable,\n  ) {\n    return Promise.all([\n      enlivenObjects<FabricObject>(objects, abortable),\n      enlivenObjectEnlivables(options, abortable),\n    ]).then(([objects, hydratedOptions]) => {\n      const group = new this(objects, {\n        ...options,\n        ...hydratedOptions,\n        layoutManager: new NoopLayoutManager(),\n      });\n      if (layoutManager) {\n        const layoutClass = classRegistry.getClass<typeof LayoutManager>(\n          layoutManager.type,\n        );\n        const strategyClass = classRegistry.getClass<typeof FitContentLayout>(\n          layoutManager.strategy,\n        );\n        group.layoutManager = new layoutClass(new strategyClass());\n      } else {\n        group.layoutManager = new LayoutManager();\n      }\n      group.layoutManager.subscribeTargets({\n        type: LAYOUT_TYPE_INITIALIZATION,\n        target: group,\n        targets: group.getObjects(),\n      });\n      group.setCoords();\n      return group;\n    });\n  }\n}\n\nclassRegistry.setClass(Group);\n"],"names":["NoopLayoutManager","LayoutManager","performLayout","groupDefaultValues","strokeWidth","subTargetCheck","caterCacheForTextChildren","selected","useSelectedFlag","interactive","Group","createCollectionMixin","FabricObject","getDefaults","_objectSpread","super","ownDefaults","constructor","objects","arguments","length","undefined","options","_defineProperty","this","Object","assign","setOptions","groupInit","onDeselect","_getCacheCanvasDimensions","dims","widthToAdd","heightToAdd","maxFontSize","_getMaxExpandedFontSizeFromTextChildren","zoomX","zoomY","width","height","groupObjects","getObjects","groupObject","fontSize","cacheExpansionFactor","maxFontSizeInGroup","_options$layoutManage","_objects","__objectSelectionTracker","__objectSelectionMonitor","bind","__objectSelectionDisposer","forEachObject","object","enterGroup","layoutManager","type","LAYOUT_TYPE_INITIALIZATION","target","targets","x","left","y","top","canEnterGroup","isDescendantOf","log","indexOf","_filterObjectsBeforeEnteringGroup","filter","index","array","add","_len","Array","_key","allowedObjects","size","_onAfterObjectsChange","LAYOUT_TYPE_ADDED","insertAt","_len2","_key2","remove","removed","LAYOUT_TYPE_REMOVED","_onObjectAdded","fire","_onObjectRemoved","removeParentTransform","exitGroup","_onStackOrderChanged","_set","key","value","prev","forEach","_shouldSetNestedCoords","removeAll","_activeObjects","_ref","activeObjects","push","splice","_watchObject","watch","on","off","group","_enterGroup","applyTransformToObject","multiplyTransformMatrices","invertTransform","calcTransformMatrix","setCoords","canvas","activeObject","getActiveObject","_exitGroup","shouldCache","ownCache","prototype","call","i","willDrawShadow","ownCaching","isGroup","isOnACache","parent","drawObject","ctx","forClipping","context","_renderBackground","_this$canvas","obj","preserveObjectStacking","save","transform","render","restore","_drawClipPath","clipPath","triggerLayout","LAYOUT_TYPE_IMPERATIVE","_transformDone","isTable","__serializeObjects","method","propertiesToInclude","_includeDefaultValues","includeDefaultValues","excludeFromExport","map","originalDefaults","data","toObject","strategy","toString","concat","complexity","dispose","unsubscribeTargets","_createSVGBgRect","reviver","backgroundColor","fillStroke","Rect","_toSVG","commons","markup","join","svgString","bg","toSVG","getSvgStyles","opacity","visibility","visible","getSvgFilter","toClipPathSVG","_createBaseClipPathSVGMarkup","horizontalAlignment","_this$canvas2","groupWidth","padding","corners","tl","offsetX","getCornerPoints","getCenterPoint","minX","Math","min","tr","bl","br","set","maxX","max","verticalAlignment","_this$canvas3","groupHeight","offsetY","minY","maxY","fromObject","_ref2","abortable","_objectWithoutProperties","_excluded","Promise","all","enlivenObjects","enlivenObjectEnlivables","then","_ref3","hydratedOptions","layoutClass","classRegistry","getClass","strategyClass","subscribeTargets","setClass"],"mappings":"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"}