import{defineProperty as t}from"../_virtual/_rollupPluginBabelHelpers.min.mjs";import{classRegistry as o}from"./ClassRegistry.min.mjs";import{Color as s}from"./color/Color.min.mjs";import{config as e}from"./config.min.mjs";import{reNum as r}from"./parser/constants.min.mjs";import{Point as i}from"./Point.min.mjs";import{uid as n}from"./util/internals/uid.min.mjs";import{pickBy as l}from"./util/misc/pick.min.mjs";import{degreesToRadians as f}from"./util/misc/radiansDegreesConversion.min.mjs";import{toFixed as a}from"./util/misc/toFixed.min.mjs";import{rotateVector as h}from"./util/misc/vectors.min.mjs";let m=function(t){return t.LIGHT_SHADOW="light_shadow",t.STRONG_SHADOW="strong_shadow",t.CUSTOM_SHADOW="custom_shadow",t.LIGHT_GLOW="light_glow",t.STRONG_GLOW="strong_glow",t.NONE="none",t}({});const u="(-?\\d+(?:\\.\\d*)?(?:px)?(?:\\s?|$))?",c=new RegExp("(?:\\s|^)"+u+u+"("+r+"?(?:px)?)?(?:\\s?|$)(?:$|\\s)"),p={color:"rgb(0,0,0)",blur:0,offsetX:0,offsetY:0,affectStroke:!1,includeDefaultValues:!0,nonScaling:!1,shadowOrGlowType:m.NONE};class d{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const o="string"==typeof t?d.parseShadow(t):t;Object.assign(this,d.ownDefaults,o),this.id=n()}static parseShadow(t){const o=t.trim(),[,s=0,e=0,r=0]=(c.exec(o)||[]).map((t=>parseFloat(t)||0));return{color:(o.replace(c,"")||"rgb(0,0,0)").trim(),offsetX:s,offsetY:e,blur:r}}isShadow(){return this.shadowOrGlowType===m.STRONG_SHADOW||this.shadowOrGlowType===m.LIGHT_SHADOW||this.shadowOrGlowType===m.CUSTOM_SHADOW}isCustomShadow(){return this.shadowOrGlowType===m.CUSTOM_SHADOW}isGlow(){return this.shadowOrGlowType===m.LIGHT_GLOW||this.shadowOrGlowType===m.STRONG_GLOW}toString(){return[this.offsetX,this.offsetY,this.blur,this.color].join("px ")}toSVG(t){const o=h(new i(this.offsetX,this.offsetY),f(-t.angle)),r=new s(this.color);let n=40,l=40;return t.width&&t.height&&(n=100*a((Math.abs(o.x)+this.blur)/t.width,e.NUM_FRACTION_DIGITS)+20,l=100*a((Math.abs(o.y)+this.blur)/t.height,e.NUM_FRACTION_DIGITS)+20),t.flipX&&(o.x*=-1),t.flipY&&(o.y*=-1),`<filter id="SVGID_${this.id}" y="-${l}%" height="${100+2*l}%" x="-${n}%" width="${100+2*n}%" >\n\t<feGaussianBlur in="SourceAlpha" stdDeviation="${a(this.blur?this.blur/2:0,e.NUM_FRACTION_DIGITS)}"></feGaussianBlur>\n\t<feOffset dx="${a(o.x,e.NUM_FRACTION_DIGITS)}" dy="${a(o.y,e.NUM_FRACTION_DIGITS)}" result="oBlur" ></feOffset>\n\t<feFlood flood-color="${r.toRgb()}" flood-opacity="${r.getAlpha()}"/>\n\t<feComposite in2="oBlur" operator="in" />\n\t<feMerge>\n\t\t<feMergeNode></feMergeNode>\n\t\t<feMergeNode in="SourceGraphic"></feMergeNode>\n\t</feMerge>\n</filter>\n`}toObject(){const t={color:this.color,blur:this.blur,offsetX:this.offsetX,offsetY:this.offsetY,affectStroke:this.affectStroke,nonScaling:this.nonScaling,type:this.constructor.type,shadowOrGlowType:this.shadowOrGlowType},o=d.ownDefaults;return this.includeDefaultValues?t:l(t,((t,s)=>t!==o[s]))}static async fromObject(t){return new this(t)}}t(d,"ownDefaults",p),t(d,"type","shadow"),o.setClass(d,"shadow");export{d as Shadow,m as ShadowOrGlowType,p as shadowDefaultValues};
//# sourceMappingURL=Shadow.min.mjs.map
