{"version":3,"file":"Canvas.min.mjs","sources":["../../../src/canvas/Canvas.ts"],"sourcesContent":["import { classRegistry } from '../ClassRegistry';\nimport { NONE } from '../constants';\nimport type {\n  CanvasEvents,\n  DragEventData,\n  ObjectEvents,\n  TEventsExtraData,\n  TPointerEvent,\n  TPointerEventNames,\n  Transform,\n} from '../EventTypeDefs';\nimport { Point } from '../Point';\nimport type { ActiveSelection } from '../shapes/ActiveSelection';\nimport type { Group } from '../shapes/Group';\nimport type { IText } from '../shapes/IText/IText';\nimport type { FabricObject } from '../shapes/Object/FabricObject';\nimport { type TToCanvasElementOptions } from '../typedefs';\nimport { isTouchEvent, stopEvent } from '../util/dom_event';\nimport { getDocumentFromElement, getWindowFromElement } from '../util/dom_misc';\nimport { sendPointToPlane } from '../util/misc/planeChange';\nimport { isActiveSelection } from '../util/typeAssertions';\nimport type { CanvasOptions, TCanvasOptions } from './CanvasOptions';\nimport { SelectableCanvas } from './SelectableCanvas';\nimport { TextEditingManager } from './TextEditingManager';\nimport { config } from '../config';\n\nconst addEventOptions = { passive: false } as EventListenerOptions;\n\nconst getEventPoints = (canvas: Canvas, e: TPointerEvent) => {\n  const viewportPoint = canvas.getViewportPoint(e);\n  const scenePoint = canvas.getScenePoint(e);\n  return {\n    viewportPoint,\n    scenePoint,\n  };\n};\n\n// just to be clear, the utils are now deprecated and those are here exactly as minifier helpers\n// because el.addEventListener can't me be minified while a const yes and we use it 47 times in this file.\n// few bytes but why give it away.\nconst addListener = (\n  el: HTMLElement | Document,\n  ...args: Parameters<HTMLElement['addEventListener']>\n) => el.addEventListener(...args);\nconst removeListener = (\n  el: HTMLElement | Document,\n  ...args: Parameters<HTMLElement['removeEventListener']>\n) => el.removeEventListener(...args);\n\nconst syntheticEventConfig = {\n  mouse: {\n    in: 'over',\n    out: 'out',\n    targetIn: 'mouseover',\n    targetOut: 'mouseout',\n    canvasIn: 'mouse:over',\n    canvasOut: 'mouse:out',\n  },\n  drag: {\n    in: 'enter',\n    out: 'leave',\n    targetIn: 'dragenter',\n    targetOut: 'dragleave',\n    canvasIn: 'drag:enter',\n    canvasOut: 'drag:leave',\n  },\n} as const;\n\ntype TSyntheticEventContext = {\n  mouse: { e: TPointerEvent };\n  drag: DragEventData;\n};\n\ninterface TouchProps {\n  numOfTouches: number;\n  totalDrift: number;\n  x: number;\n  y: number;\n}\n\nexport class Canvas extends SelectableCanvas implements CanvasOptions {\n  /**\n   * Contains the id of the touch event that owns the fabric transform\n   * @type Number\n   * @private\n   */\n  declare mainTouchId?: number;\n\n  declare enablePointerEvents: boolean;\n\n  /**\n   * *PMW* added property to handle drift deviance for better experience on highly pixelated devices.\n   */\n  public touchProps: undefined | TouchProps;\n\n  /**\n   * *PMW* added property to handle drift deviance for better experience on highly pixelated devices.\n   */\n  public allowedTouchDriftDeviance = 5;\n\n  /**\n   * Holds a reference to a setTimeout timer for event synchronization\n   * @type number\n   * @private\n   */\n  declare private _willAddMouseDown: number;\n\n  /**\n   * Holds a reference to an object on the canvas that is receiving the drag over event.\n   * @type FabricObject\n   * @private\n   */\n  declare private _draggedoverTarget?: FabricObject;\n\n  /**\n   * Holds a reference to an object on the canvas from where the drag operation started\n   * @type FabricObject\n   * @private\n   */\n  declare private _dragSource?: FabricObject;\n\n  /**\n   * Holds a reference to an object on the canvas that is the current drop target\n   * May differ from {@link _draggedoverTarget}\n   * @todo inspect whether {@link _draggedoverTarget} and {@link _dropTarget} should be merged somehow\n   * @type FabricObject\n   * @private\n   */\n  declare private _dropTarget: FabricObject<ObjectEvents> | undefined;\n\n  /**\n   * a boolean that keeps track of the click state during a cycle of mouse down/up.\n   * If a mouse move occurs it becomes false.\n   * Is true by default, turns false on mouse move.\n   * Used to determine if a mouseUp is a click\n   */\n  private _isClick: boolean;\n\n  textEditingManager = new TextEditingManager(this);\n\n  constructor(el?: string | HTMLCanvasElement, options: TCanvasOptions = {}) {\n    super(el, options);\n    // bind event handlers\n    (\n      [\n        '_onMouseDown',\n        '_onTouchStart',\n        '_onMouseMove',\n        '_onMouseUp',\n        //*PMW* Added support for drift deviance\n        '_onTouchMove',\n        '_onTouchEnd',\n        '_onResize',\n        // '_onGesture',\n        // '_onDrag',\n        // '_onShake',\n        // '_onLongPress',\n        // '_onOrientationChange',\n        '_onMouseWheel',\n        '_onMouseOut',\n        '_onMouseEnter',\n        '_onContextMenu',\n        '_onClick',\n        '_onDragStart',\n        '_onDragEnd',\n        '_onDragProgress',\n        '_onDragOver',\n        '_onDragEnter',\n        '_onDragLeave',\n        '_onDrop',\n      ] as (keyof this)[]\n    ).forEach((eventHandler) => {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n      this[eventHandler] = (this[eventHandler] as Function).bind(this);\n    });\n    // register event handlers\n    this.addOrRemove(addListener);\n  }\n\n  /**\n   * return an event prefix pointer or mouse.\n   * @private\n   */\n  private _getEventPrefix() {\n    return this.enablePointerEvents ? 'pointer' : 'mouse';\n  }\n\n  addOrRemove(functor: any, forTouch = false) {\n    const canvasElement = this.upperCanvasEl,\n      eventTypePrefix = this._getEventPrefix();\n    functor(getWindowFromElement(canvasElement), 'resize', this._onResize);\n    functor(canvasElement, eventTypePrefix + 'down', this._onMouseDown);\n    functor(\n      canvasElement,\n      `${eventTypePrefix}move`,\n      this._onMouseMove,\n      addEventOptions,\n    );\n    functor(canvasElement, `${eventTypePrefix}out`, this._onMouseOut);\n    functor(canvasElement, `${eventTypePrefix}enter`, this._onMouseEnter);\n    functor(canvasElement, 'wheel', this._onMouseWheel, { passive: false });\n    functor(canvasElement, 'contextmenu', this._onContextMenu);\n    if (!forTouch) {\n      functor(canvasElement, 'click', this._onClick);\n      functor(canvasElement, 'dblclick', this._onClick);\n    }\n    functor(canvasElement, 'dragstart', this._onDragStart);\n    functor(canvasElement, 'dragend', this._onDragEnd);\n    functor(canvasElement, 'dragover', this._onDragOver);\n    functor(canvasElement, 'dragenter', this._onDragEnter);\n    functor(canvasElement, 'dragleave', this._onDragLeave);\n    functor(canvasElement, 'drop', this._onDrop);\n    if (!this.enablePointerEvents) {\n      functor(canvasElement, 'touchstart', this._onTouchStart, addEventOptions);\n    }\n  }\n\n  /**\n   * Removes all event listeners, used when disposing the instance\n   */\n  removeListeners() {\n    this.addOrRemove(removeListener);\n    // if you dispose on a mouseDown, before mouse up, you need to clean document to...\n    const eventTypePrefix = this._getEventPrefix();\n    const doc = getDocumentFromElement(this.upperCanvasEl);\n    removeListener(\n      doc,\n      `${eventTypePrefix}up`,\n      this._onMouseUp as EventListener,\n    );\n    removeListener(\n      doc,\n      'touchend',\n      this._onTouchEnd as EventListener,\n      addEventOptions,\n    );\n    removeListener(\n      doc,\n      `${eventTypePrefix}move`,\n      this._onMouseMove as EventListener,\n      addEventOptions,\n    );\n    // *PMW* modified code. calling onTouchMove instead of _onMouseMove to handle drift deviance\n    removeListener(\n      doc,\n      'touchmove',\n      this._onTouchMove as EventListener,\n      addEventOptions,\n    );\n    clearTimeout(this._willAddMouseDown);\n  }\n\n  /**\n   * @private\n   * @param {Event} [e] Event object fired on wheel event\n   */\n  private _onMouseWheel(e: MouseEvent) {\n    this._cacheTransformEventData(e);\n    this._handleEvent(e, 'wheel');\n    this._resetTransformEventData();\n  }\n\n  /**\n   * @private\n   * @param {Event} e Event object fired on mousedown\n   */\n  private _onMouseOut(e: TPointerEvent) {\n    const target = this._hoveredTarget;\n    const shared = {\n      e,\n      ...getEventPoints(this, e),\n    };\n    this.fire('mouse:out', { ...shared, target });\n    this._hoveredTarget = undefined;\n    target && target.fire('mouseout', { ...shared });\n    this._hoveredTargets.forEach((nestedTarget) => {\n      this.fire('mouse:out', { ...shared, target: nestedTarget });\n      nestedTarget && nestedTarget.fire('mouseout', { ...shared });\n    });\n    this._hoveredTargets = [];\n  }\n\n  /**\n   * @private\n   * Used when the mouse cursor enter the canvas from outside\n   * @param {Event} e Event object fired on mouseenter\n   */\n  private _onMouseEnter(e: TPointerEvent) {\n    // This find target and consequent 'mouse:over' is used to\n    // clear old instances on hovered target.\n    // calling findTarget has the side effect of killing target.__corner.\n    // as a short term fix we are not firing this if we are currently transforming.\n    // as a long term fix we need to separate the action of finding a target with the\n    // side effects we added to it.\n    const { target } = this.findTarget(e);\n    // we fire the event only when there is no target, if there is a target, the specific\n    // target event will fire.\n    if (!this._currentTransform && !target) {\n      this.fire('mouse:over', {\n        e,\n        ...getEventPoints(this, e),\n      });\n      this._hoveredTarget = undefined;\n      this._hoveredTargets = [];\n    }\n  }\n\n  /**\n   * supports native like text dragging\n   * @private\n   * @param {DragEvent} e\n   */\n  private _onDragStart(e: DragEvent) {\n    this._isClick = false;\n    const activeObject = this.getActiveObject();\n    if (activeObject && activeObject.onDragStart(e)) {\n      this._dragSource = activeObject;\n      const options = { e, target: activeObject };\n      this.fire('dragstart', options);\n      activeObject.fire('dragstart', options);\n      addListener(\n        this.upperCanvasEl,\n        'drag',\n        this._onDragProgress as EventListener,\n      );\n      return;\n    }\n    stopEvent(e);\n  }\n\n  /**\n   * First we clear top context where the effects are being rendered.\n   * Then we render the effects.\n   * Doing so will render the correct effect for all cases including an overlap between `source` and `target`.\n   * @private\n   */\n  private _renderDragEffects(\n    e: DragEvent,\n    source?: FabricObject,\n    target?: FabricObject,\n  ) {\n    let dirty = false;\n    // clear top context\n    const dropTarget = this._dropTarget;\n    if (dropTarget && dropTarget !== source && dropTarget !== target) {\n      dropTarget.clearContextTop();\n      dirty = true;\n    }\n    source?.clearContextTop();\n    target !== source && target?.clearContextTop();\n    // render effects\n    const ctx = this.contextTop;\n    ctx.save();\n    ctx.transform(...this.viewportTransform);\n    if (source) {\n      ctx.save();\n      source.transform(ctx);\n      source.renderDragSourceEffect(e);\n      ctx.restore();\n      dirty = true;\n    }\n    if (target) {\n      ctx.save();\n      target.transform(ctx);\n      target.renderDropTargetEffect(e);\n      ctx.restore();\n      dirty = true;\n    }\n    ctx.restore();\n    dirty && (this.contextTopDirty = true);\n  }\n\n  /**\n   * supports native like text dragging\n   * https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API/Drag_operations#finishing_a_drag\n   * @private\n   * @param {DragEvent} e\n   */\n  private _onDragEnd(e: DragEvent) {\n    const { currentSubTargets } = this.findTarget(e);\n    const didDrop = !!e.dataTransfer && e.dataTransfer.dropEffect !== NONE,\n      dropTarget = didDrop ? this._activeObject : undefined,\n      options = {\n        e,\n        target: this._dragSource as FabricObject,\n        subTargets: currentSubTargets,\n        dragSource: this._dragSource as FabricObject,\n        didDrop,\n        dropTarget: dropTarget as FabricObject,\n      };\n    removeListener(\n      this.upperCanvasEl,\n      'drag',\n      this._onDragProgress as EventListener,\n    );\n    this.fire('dragend', options);\n    this._dragSource && this._dragSource.fire('dragend', options);\n    delete this._dragSource;\n    // we need to call mouse up synthetically because the browser won't\n    this._onMouseUp(e);\n  }\n\n  /**\n   * fire `drag` event on canvas and drag source\n   * @private\n   * @param {DragEvent} e\n   */\n  private _onDragProgress(e: DragEvent) {\n    const options = {\n      e,\n      target: this._dragSource,\n      dragSource: this._dragSource,\n      dropTarget: this._draggedoverTarget as FabricObject,\n    };\n    this.fire('drag', options);\n    this._dragSource && this._dragSource.fire('drag', options);\n  }\n\n  /**\n   * prevent default to allow drop event to be fired\n   * https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API/Drag_operations#specifying_drop_targets\n   * @private\n   * @param {DragEvent} [e] Event object fired on Event.js shake\n   */\n  private _onDragOver(e: DragEvent) {\n    const eventType = 'dragover';\n    const { currentContainer: target, currentSubTargets } = this.findTarget(e);\n    const dragSource = this._dragSource as FabricObject;\n    const options = {\n      e,\n      target,\n      subTargets: currentSubTargets,\n      dragSource,\n      canDrop: false,\n      dropTarget: undefined,\n    };\n    let dropTarget;\n    //  fire on canvas\n    this.fire(eventType, options);\n    //  make sure we fire dragenter events before dragover\n    //  if dragleave is needed, object will not fire dragover so we don't need to trouble ourselves with it\n    this._fireEnterLeaveEvents(e, target, options);\n    if (target) {\n      if (target.canDrop(e)) {\n        dropTarget = target;\n      }\n      target.fire(eventType, options);\n    }\n    //  propagate the event to subtargets\n    for (let i = 0; i < currentSubTargets.length; i++) {\n      const subTarget = currentSubTargets[i];\n      // accept event only if previous targets didn't (the accepting target calls `preventDefault` to inform that the event is taken)\n      // TODO: verify if those should loop in inverse order then?\n      // what is the order of subtargets?\n      if (subTarget.canDrop(e)) {\n        dropTarget = subTarget;\n      }\n      subTarget.fire(eventType, options);\n    }\n    //  render drag effects now that relations between source and target is clear\n    this._renderDragEffects(e, dragSource, dropTarget);\n    this._dropTarget = dropTarget;\n  }\n\n  /**\n   * fire `dragleave` on `dragover` targets\n   * @private\n   * @param {Event} [e] Event object fired on Event.js shake\n   */\n  private _onDragEnter(e: DragEvent) {\n    const { currentContainer, currentSubTargets } = this.findTarget(e);\n    const options = {\n      e,\n      target: currentContainer,\n      subTargets: currentSubTargets,\n      dragSource: this._dragSource,\n    };\n    this.fire('dragenter', options);\n    //  fire dragenter on targets\n    this._fireEnterLeaveEvents(e, currentContainer, options);\n  }\n\n  /**\n   * fire `dragleave` on `dragover` targets\n   * @private\n   * @param {Event} [e] Event object fired on Event.js shake\n   */\n  private _onDragLeave(e: DragEvent) {\n    const { currentSubTargets } = this.findTarget(e);\n    const options = {\n      e,\n      target: this._draggedoverTarget,\n      subTargets: currentSubTargets,\n      dragSource: this._dragSource,\n    };\n    this.fire('dragleave', options);\n\n    //  fire dragleave on targets\n    this._fireEnterLeaveEvents(e, undefined, options);\n    this._renderDragEffects(e, this._dragSource);\n    this._dropTarget = undefined;\n    this._hoveredTargets = [];\n  }\n\n  /**\n   * `drop:before` is a an event that allows you to schedule logic\n   * before the `drop` event. Prefer `drop` event always, but if you need\n   * to run some drop-disabling logic on an event, since there is no way\n   * to handle event handlers ordering, use `drop:before`\n   * @private\n   * @param {Event} e\n   */\n  private _onDrop(e: DragEvent) {\n    const { currentContainer, currentSubTargets } = this.findTarget(e);\n    const options = this._basicEventHandler('drop:before', {\n      e,\n      target: currentContainer,\n      subTargets: currentSubTargets,\n      dragSource: this._dragSource,\n      ...getEventPoints(this, e),\n    });\n    //  will be set by the drop target\n    options.didDrop = false;\n    //  will be set by the drop target, used in case options.target refuses the drop\n    options.dropTarget = undefined;\n    //  fire `drop`\n    this._basicEventHandler('drop', options);\n    //  inform canvas of the drop\n    //  we do this because canvas was unaware of what happened at the time the `drop` event was fired on it\n    //  use for side effects\n    this.fire('drop:after', options);\n  }\n\n  /**\n   * @private\n   * @param {Event} e Event object fired on mousedown\n   */\n  private _onContextMenu(e: TPointerEvent): false {\n    const { target, subTargets } = this.findTarget(e);\n    const options = this._basicEventHandler('contextmenu:before', {\n      e,\n      target,\n      subTargets,\n    });\n    // TODO: this line is silly because the dev can subscribe to the event and prevent it themselves\n    this.stopContextMenu && stopEvent(e);\n    this._basicEventHandler('contextmenu', options);\n    return false;\n  }\n\n  /**\n   * @private\n   * @param {Event} e Event object fired on mousedown\n   */\n  private _onClick(e: TPointerEvent) {\n    const clicks = e.detail;\n    if (clicks > 3 || clicks < 2) return;\n    this._cacheTransformEventData(e);\n    clicks == 2 && e.type === 'dblclick' && this._handleEvent(e, 'dblclick');\n    clicks == 3 && this._handleEvent(e, 'tripleclick');\n    this._resetTransformEventData();\n  }\n\n  /**\n   * This supports gesture event firing\n   * It is a method to keep some code organized, it exposes private methods\n   * in a way that works and still keep them private\n   * This is supposed to mirror _handleEvent\n   */\n  fireEventFromPointerEvent(\n    e: TPointerEvent,\n    eventName: keyof CanvasEvents,\n    secondaryName: keyof ObjectEvents,\n    extraData:\n      | Record<string, unknown>\n      | { rotation: number }\n      | { ping: number } = {},\n  ) {\n    this._cacheTransformEventData(e);\n    const { target, subTargets } = this.findTarget(e),\n      options = {\n        e,\n        target,\n        subTargets,\n        ...getEventPoints(this, e),\n        transform: this._currentTransform,\n        ...extraData,\n      };\n    this.fire(eventName, options);\n    // this may be a little be more complicated of what we want to handle\n    target && target.fire(secondaryName, options);\n    for (let i = 0; i < subTargets.length; i++) {\n      subTargets[i] !== target && subTargets[i].fire(secondaryName, options);\n    }\n    this._resetTransformEventData();\n  }\n\n  /**\n   * Return a the id of an event.\n   * returns either the pointerId or the identifier or 0 for the mouse event\n   * @private\n   * @param {Event} evt Event object\n   */\n  getPointerId(evt: TouchEvent | PointerEvent): number {\n    const changedTouches = (evt as TouchEvent).changedTouches;\n\n    if (changedTouches) {\n      return changedTouches[0] && changedTouches[0].identifier;\n    }\n\n    if (this.enablePointerEvents) {\n      return (evt as PointerEvent).pointerId;\n    }\n\n    return -1;\n  }\n\n  /**\n   * Determines if an event has the id of the event that is considered main\n   * @private\n   * @param {evt} event Event object\n   */\n  _isMainEvent(evt: TPointerEvent): boolean {\n    if ((evt as PointerEvent).isPrimary === true) {\n      return true;\n    }\n    if ((evt as PointerEvent).isPrimary === false) {\n      return false;\n    }\n    if (evt.type === 'touchend' && (evt as TouchEvent).touches.length === 0) {\n      return true;\n    }\n    if ((evt as TouchEvent).changedTouches) {\n      return (\n        (evt as TouchEvent).changedTouches[0].identifier === this.mainTouchId\n      );\n    }\n    return true;\n  }\n\n  /**\n   * @private\n   * @param {Event} e Event object fired on mousedown\n   */\n  _onTouchStart(e: TouchEvent) {\n    this._cacheTransformEventData(e);\n    // we will prevent scrolling if allowTouchScrolling is not enabled and\n    let shouldPreventScrolling = !this.allowTouchScrolling;\n    const currentActiveObject = this._activeObject;\n    if (this.mainTouchId === undefined) {\n      this.mainTouchId = this.getPointerId(e);\n    }\n    this.__onMouseDown(e);\n    const { target } = this.findTarget(e);\n    // after executing fabric logic for mouse down let's see\n    // if we didn't change target or if we are drawing\n    // we want to prevent scrolling anyway\n    if (\n      this.isDrawingMode ||\n      (currentActiveObject && target === currentActiveObject)\n    ) {\n      shouldPreventScrolling = true;\n    }\n    // prevent default, will block scrolling from start\n    shouldPreventScrolling && e.preventDefault();\n    const canvasElement = this.upperCanvasEl,\n      eventTypePrefix = this._getEventPrefix();\n    const doc = getDocumentFromElement(canvasElement);\n    addListener(\n      doc,\n      'touchend',\n      this._onTouchEnd as EventListener,\n      addEventOptions,\n    );\n    // *PMW* modified code. calling onTouchMove instead of _onMouseMove to handle drift deviance\n    addListener(\n      doc,\n      'touchmove',\n      this._onTouchMove as EventListener,\n      addEventOptions\n    );\n    // Unbind mousedown to prevent double triggers from touch devices\n    removeListener(\n      canvasElement,\n      `${eventTypePrefix}down`,\n      this._onMouseDown as EventListener,\n    );\n    this._resetTransformEventData();\n  }\n\n  /**\n   * @private\n   * @param {Event} e Event object fired on mousedown\n   */\n  _onMouseDown(e: TPointerEvent) {\n    this._cacheTransformEventData(e);\n    this.__onMouseDown(e);\n    const canvasElement = this.upperCanvasEl,\n      eventTypePrefix = this._getEventPrefix();\n    // switch from moving on the canvas element to moving on the document\n    removeListener(\n      canvasElement,\n      `${eventTypePrefix}move`,\n      this._onMouseMove as EventListener,\n      addEventOptions,\n    );\n    const doc = getDocumentFromElement(canvasElement);\n    addListener(doc, `${eventTypePrefix}up`, this._onMouseUp as EventListener);\n    addListener(\n      doc,\n      `${eventTypePrefix}move`,\n      this._onMouseMove as EventListener,\n      addEventOptions,\n    );\n    this._resetTransformEventData();\n  }\n\n  /**\n   * @private\n   * @param {Event} e Event object fired on mousedown\n   */\n  _onTouchEnd(e: TouchEvent) {\n    if (e.touches.length > 0) {\n      // if there are still touches stop here\n      return;\n    }\n    this._cacheTransformEventData(e);\n    this.__onMouseUp(e);\n    this._resetTransformEventData();\n    delete this.mainTouchId;\n    const eventTypePrefix = this._getEventPrefix();\n    const doc = getDocumentFromElement(this.upperCanvasEl);\n    removeListener(\n      doc,\n      'touchend',\n      this._onTouchEnd as EventListener,\n      addEventOptions,\n    );\n    // *PMW* modified code. calling onTouchMove instead of _onMouseMove to handle drift deviance\n    removeListener(\n      doc,\n      'touchmove',\n      this._onTouchMove as EventListener,\n      addEventOptions,\n    );\n    if (this._willAddMouseDown) {\n      clearTimeout(this._willAddMouseDown);\n    }\n    this._willAddMouseDown = setTimeout(() => {\n      // Wait 400ms before rebinding mousedown to prevent double triggers\n      // from touch devices\n      addListener(\n        this.upperCanvasEl,\n        `${eventTypePrefix}down`,\n        this._onMouseDown as EventListener,\n      );\n      this._willAddMouseDown = 0;\n    }, 400) as unknown as number;\n  }\n\n  /**\n   * @private\n   * @param {Event} e Event object fired on mouseup\n   */\n  _onMouseUp(e: TPointerEvent) {\n    this._cacheTransformEventData(e);\n    this.__onMouseUp(e);\n    const canvasElement = this.upperCanvasEl,\n      eventTypePrefix = this._getEventPrefix();\n    if (this._isMainEvent(e)) {\n      const doc = getDocumentFromElement(this.upperCanvasEl);\n      removeListener(\n        doc,\n        `${eventTypePrefix}up`,\n        this._onMouseUp as EventListener,\n      );\n      removeListener(\n        doc,\n        `${eventTypePrefix}move`,\n        this._onMouseMove as EventListener,\n        addEventOptions,\n      );\n      addListener(\n        canvasElement,\n        `${eventTypePrefix}move`,\n        this._onMouseMove as EventListener,\n        addEventOptions,\n      );\n    }\n    this._resetTransformEventData();\n  }\n\n  /**\n   * @private\n   * @param {Event} e Event object fired on mousemove\n   */\n  _onMouseMove(e: TPointerEvent) {\n    this._cacheTransformEventData(e);\n\n    const activeObject = this.getActiveObject();\n    !this.allowTouchScrolling &&\n      (!activeObject ||\n        // a drag event sequence is started by the active object flagging itself on mousedown / mousedown:before\n        // we must not prevent the event's default behavior in order for the window to start dragging\n        !activeObject.shouldStartDragging(e)) &&\n      e.preventDefault &&\n      e.preventDefault();\n    this.__onMouseMove(e);\n    this._resetTransformEventData();\n  }\n\n  /**\n   * *PMW* added function. Calculates drift deviance since touch start. If total number of touches is one, and totalDrift is less than allowedTouchDriftDeviance, then we don't skip the onMouseMove call.\n   * @param {Event} e Event object fired on touchmove\n   */\n  _onTouchMove(e: TPointerEvent) {\n    if (this.touchProps && this.touchProps.numOfTouches === 1) {\n      const event = e as TouchEvent;\n      const dx = event.touches[0].pageX - this.touchProps.x;\n      const dy = event.touches[0].pageY - this.touchProps.y;\n      this.touchProps.totalDrift += Math.sqrt(dx * dx + dy * dy);\n      this.touchProps.x = event.touches[0].pageX;\n      this.touchProps.y = event.touches[0].pageY;\n\n      if (this.touchProps.totalDrift < this.allowedTouchDriftDeviance) {\n        return;\n      }\n    }\n    this._onMouseMove(e);\n  }\n\n  /**\n   * @private\n   */\n  _onResize() {\n    this.calcOffset();\n    this._resetTransformEventData();\n  }\n\n  /**\n   * Decides whether the canvas should be redrawn in mouseup and mousedown events.\n   * @private\n   * @param {Object} target\n   */\n  _shouldRender(target: FabricObject | undefined) {\n    const activeObject = this.getActiveObject();\n    // if just one of them is available or if they are both but are different objects\n    // this covers: switch of target, from target to no target, selection of target\n    // multiSelection with key and mouse\n    return (\n      !!activeObject !== !!target ||\n      (activeObject && target && activeObject !== target)\n    );\n  }\n\n  /**\n   * Method that defines the actions when mouse is released on canvas.\n   * The method resets the currentTransform parameters, store the image corner\n   * position in the image object and render the canvas on top.\n   * @private\n   * @param {Event} e Event object fired on mouseup\n   */\n  __onMouseUp(e: TPointerEvent) {\n    this._handleEvent(e, 'up:before');\n\n    const transform = this._currentTransform;\n    const isClick = this._isClick;\n    const { target } = this.findTarget(e);\n\n    // if right/middle click just fire events and return\n    // target undefined will make the _handleEvent search the target\n    const { button } = e as MouseEvent;\n    if (button) {\n      ((this.fireMiddleClick && button === 1) ||\n        (this.fireRightClick && button === 2)) &&\n        this._handleEvent(e, 'up');\n      return;\n    }\n\n    if (this.isDrawingMode && this._isCurrentlyDrawing) {\n      this._onMouseUpInDrawingMode(e);\n      return;\n    }\n\n    if (!this._isMainEvent(e)) {\n      return;\n    }\n    let shouldRender = false;\n    if (transform) {\n      this._finalizeCurrentTransform(e);\n      shouldRender = transform.actionPerformed;\n    }\n    if (!isClick) {\n      const targetWasActive = target === this._activeObject;\n      this.handleSelection(e);\n      if (!shouldRender) {\n        shouldRender =\n          this._shouldRender(target) ||\n          (!targetWasActive && target === this._activeObject);\n      }\n    }\n    let pointer, corner;\n    if (target) {\n      const found = target.findControl(\n        this.getViewportPoint(e),\n        isTouchEvent(e),\n      );\n      const { key, control } = found || {};\n      corner = key;\n      if (\n        target.selectable &&\n        target !== this._activeObject &&\n        target.activeOn === 'up'\n      ) {\n        this.setActiveObject(target, e);\n        shouldRender = true;\n      } else if (control) {\n        const mouseUpHandler = control.getMouseUpHandler(e, target, control);\n        if (mouseUpHandler) {\n          pointer = this.getScenePoint(e);\n          mouseUpHandler.call(control, e, transform!, pointer.x, pointer.y);\n        }\n      }\n      target.isMoving = false;\n    }\n    // if we are ending up a transform on a different control or a new object\n    // fire the original mouse up from the corner that started the transform\n    if (\n      transform &&\n      (transform.target !== target || transform.corner !== corner)\n    ) {\n      const originalControl =\n          transform.target && transform.target.controls[transform.corner],\n        originalMouseUpHandler =\n          originalControl &&\n          originalControl.getMouseUpHandler(\n            e,\n            transform.target,\n            originalControl,\n          );\n      pointer = pointer || this.getScenePoint(e);\n      originalMouseUpHandler &&\n        originalMouseUpHandler.call(\n          originalControl,\n          e,\n          transform,\n          pointer.x,\n          pointer.y,\n        );\n    }\n    this._setCursorFromEvent(e, target);\n    this._handleEvent(e, 'up');\n    this._groupSelector = null;\n    this._currentTransform = null;\n    // reset the target information about which corner is selected\n    target && (target.__corner = undefined);\n    if (shouldRender) {\n      this.requestRenderAll();\n    } else if (!isClick && !(this._activeObject as IText)?.isEditing) {\n      this.renderTop();\n    }\n\n    if (config.isCanvasTwoFingerPanning) {\n      config.isCanvasTwoFingerPanning = false;\n    }\n  }\n\n  _basicEventHandler<T extends keyof (CanvasEvents | ObjectEvents)>(\n    eventType: T,\n    options: (CanvasEvents & ObjectEvents)[T],\n  ) {\n    const { target, subTargets = [] } = options as {\n      target?: FabricObject;\n      subTargets: FabricObject[];\n    };\n    this.fire(eventType, options);\n    target && target.fire(eventType, options);\n    for (let i = 0; i < subTargets.length; i++) {\n      subTargets[i] !== target && subTargets[i].fire(eventType, options);\n    }\n    return options;\n  }\n\n  /**\n   * @private\n   * Handle event firing for target and subtargets\n   * @param {TPointerEvent} e event from mouse\n   * @param {TPointerEventNames} eventType\n   */\n  _handleEvent<T extends TPointerEventNames>(\n    e: TPointerEvent,\n    eventType: T,\n    extraData?: TEventsExtraData[T],\n  ) {\n    const { target, subTargets } = this.findTarget(e),\n      options: CanvasEvents[`mouse:${T}`] = {\n        e,\n        target,\n        subTargets,\n        ...getEventPoints(this, e),\n        transform: this._currentTransform,\n        ...(eventType === 'down:before' || eventType === 'down'\n          ? extraData\n          : {}),\n      } as CanvasEvents[`mouse:${T}`];\n    if (eventType === 'up:before' || eventType === 'up') {\n      (options as CanvasEvents[`mouse:up`]).isClick = this._isClick;\n    }\n\n    this.fire(`mouse:${eventType}`, options);\n    // this may be a little be more complicated of what we want to handle\n    target && target.fire(`mouse${eventType}`, options);\n    for (let i = 0; i < subTargets.length; i++) {\n      subTargets[i] !== target &&\n        subTargets[i].fire(`mouse${eventType}`, options);\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} e Event object fired on mousedown\n   */\n  _onMouseDownInDrawingMode(e: TPointerEvent) {\n    this._isCurrentlyDrawing = true;\n    if (this.getActiveObject()) {\n      this.discardActiveObject(e);\n      this.requestRenderAll();\n    }\n    // TODO: this is a scene point so it should be renamed\n    const pointer = this.getScenePoint(e);\n    this.freeDrawingBrush &&\n      this.freeDrawingBrush.onMouseDown(pointer, { e, pointer });\n    this._handleEvent(e, 'down', { alreadySelected: false });\n  }\n\n  /**\n   * @private\n   * @param {Event} e Event object fired on mousemove\n   */\n  _onMouseMoveInDrawingMode(e: TPointerEvent) {\n    if (this._isCurrentlyDrawing) {\n      const pointer = this.getScenePoint(e);\n      this.freeDrawingBrush &&\n        this.freeDrawingBrush.onMouseMove(pointer, {\n          e,\n          // this is an absolute pointer, the naming is wrong\n          pointer,\n        });\n    }\n    this.setCursor(this.freeDrawingCursor);\n    this._handleEvent(e, 'move');\n  }\n\n  /**\n   * @private\n   * @param {Event} e Event object fired on mouseup\n   */\n  _onMouseUpInDrawingMode(e: TPointerEvent) {\n    const pointer = this.getScenePoint(e);\n    if (this.freeDrawingBrush) {\n      this._isCurrentlyDrawing = !!this.freeDrawingBrush.onMouseUp({\n        e: e,\n        // this is an absolute pointer, the naming is wrong\n        pointer,\n      });\n    } else {\n      this._isCurrentlyDrawing = false;\n    }\n    this._handleEvent(e, 'up');\n  }\n\n  /**\n   * Method that defines the actions when mouse is clicked on canvas.\n   * The method inits the currentTransform parameters and renders all the\n   * canvas so the current image can be placed on the top canvas and the rest\n   * in on the container one.\n   * @private\n   * @param {Event} e Event object fired on mousedown\n   */\n  __onMouseDown(e: TPointerEvent) {\n    // *PMW* added condition. Skip the object transformation while the canvas is being two-finger panned.\n    if ('touches' in e && e.touches.length === 2 || config.isCanvasTwoFingerPanning) {\n      return;\n    }\n\n    this._isClick = true;\n    this._handleEvent(e, 'down:before');\n\n    let { target } = this.findTarget(e);\n    let alreadySelected = !!target && target === this._activeObject;\n    // if right/middle click just fire events\n    const { button } = e as MouseEvent;\n    if (button) {\n      ((this.fireMiddleClick && button === 1) ||\n        (this.fireRightClick && button === 2)) &&\n        this._handleEvent(e, 'down', {\n          alreadySelected,\n        });\n      return;\n    }\n\n    if (this.isDrawingMode) {\n      this._onMouseDownInDrawingMode(e);\n      return;\n    }\n\n    if (!this._isMainEvent(e)) {\n      return;\n    }\n\n    // ignore if some object is being transformed at this moment\n    if (this._currentTransform) {\n      return;\n    }\n\n    let shouldRender = this._shouldRender(target);\n    let grouped = false;\n    if (this.handleMultiSelection(e, target)) {\n      // active object might have changed while grouping\n      target = this._activeObject;\n      grouped = true;\n      shouldRender = true;\n    } else if (this._shouldClearSelection(e, target)) {\n      this.discardActiveObject(e);\n    }\n    // we start a group selector rectangle if\n    // selection is enabled\n    // and there is no target, or the following 3 conditions are satisfied:\n    // target is not selectable ( otherwise we selected it )\n    // target is not editing\n    // target is not already selected ( otherwise we drag )\n    if (\n      this.selection &&\n      !config.disableGroupSelector &&\n      (!target ||\n        (!target.selectable &&\n          !(target as IText).isEditing &&\n          target !== this._activeObject))\n    ) {\n      const p = this.getScenePoint(e);\n      this._groupSelector = {\n        x: p.x,\n        y: p.y,\n        deltaY: 0,\n        deltaX: 0,\n      };\n    }\n\n    // check again because things could have changed\n    alreadySelected = !!target && target === this._activeObject;\n    if (target) {\n      if (target.selectable && target.activeOn === 'down') {\n        this.setActiveObject(target, e);\n      }\n      const handle = target.findControl(\n        this.getViewportPoint(e),\n        isTouchEvent(e),\n      );\n      // *PMW* added code. Added fabric.enableGroupSelection to the condition to enable dragging of active selection.\n      if (target === this._activeObject && (handle || !grouped || config.enableGroupSelection)) {\n        this._setupCurrentTransform(e, target, alreadySelected);\n        const control = handle ? handle.control : undefined,\n          pointer = this.getScenePoint(e),\n          mouseDownHandler =\n            control && control.getMouseDownHandler(e, target, control);\n        mouseDownHandler &&\n          mouseDownHandler.call(\n            control,\n            e,\n            this._currentTransform!,\n            pointer.x,\n            pointer.y,\n          );\n      }\n    }\n    //  we clear `_objectsToRender` in case of a change in order to repopulate it at rendering\n    //  run before firing the `down` event to give the dev a chance to populate it themselves\n    shouldRender && (this._objectsToRender = undefined);\n    this._handleEvent(e, 'down', { alreadySelected: alreadySelected });\n    // we must renderAll so that we update the visuals\n    shouldRender && this.requestRenderAll();\n  }\n\n  /**\n   * reset cache form common information needed during event processing\n   * @private\n   */\n  _resetTransformEventData() {\n    this._targetInfo = this._viewportPoint = this._scenePoint = undefined;\n  }\n\n  /**\n   * Cache common information needed during event processing\n   * @private\n   * @param {Event} e Event object fired on event\n   */\n  _cacheTransformEventData(e: TPointerEvent) {\n    // reset in order to avoid stale caching\n    this._resetTransformEventData();\n    this._viewportPoint = this.getViewportPoint(e);\n    this._scenePoint = sendPointToPlane(\n      this._viewportPoint,\n      undefined,\n      this.viewportTransform,\n    );\n    this._targetInfo = this.findTarget(e);\n    // TODO: investigate better if this can be made less implicit in the code\n    if (this._currentTransform) {\n      this._targetInfo.target = this._currentTransform.target;\n    }\n  }\n\n  /**\n   * Method that defines the actions when mouse is hovering the canvas.\n   * The currentTransform parameter will define whether the user is rotating/scaling/translating\n   * an image or neither of them (only hovering). A group selection is also possible and would cancel\n   * all any other type of action.\n   * In case of an image transformation only the top canvas will be rendered.\n   * @private\n   * @param {Event} e Event object fired on mousemove\n   */\n  __onMouseMove(e: TPointerEvent) {\n    if(config.isCanvasTwoFingerPanning){\n      return;\n    }\n    this._isClick = false;\n    this._handleEvent(e, 'move:before');\n\n    if (this.isDrawingMode) {\n      this._onMouseMoveInDrawingMode(e);\n      return;\n    }\n\n    if (!this._isMainEvent(e)) {\n      return;\n    }\n\n    const groupSelector = this._groupSelector;\n\n    // We initially clicked in an empty area, so we draw a box for multiple selection\n    if (groupSelector) {\n      const pointer = this.getScenePoint(e);\n\n      groupSelector.deltaX = pointer.x - groupSelector.x;\n      groupSelector.deltaY = pointer.y - groupSelector.y;\n\n      this.renderTop();\n    } else if (!this._currentTransform) {\n      const { target } = this.findTarget(e);\n      this._setCursorFromEvent(e, target);\n      this._fireOverOutEvents(e, target);\n    } else {\n      this._transformObject(e);\n    }\n    this.textEditingManager.onMouseMove(e);\n    this._handleEvent(e, 'move');\n  }\n\n  /**\n   * Manage the mouseout, mouseover events for the fabric object on the canvas\n   * @param {Fabric.Object} target the target where the target from the mousemove event\n   * @param {Event} e Event object fired on mousemove\n   * @private\n   */\n  _fireOverOutEvents(e: TPointerEvent, target?: FabricObject) {\n    const { _hoveredTarget, _hoveredTargets } = this,\n      { subTargets } = this.findTarget(e),\n      length = Math.max(_hoveredTargets.length, subTargets.length);\n\n    this.fireSyntheticInOutEvents('mouse', {\n      e,\n      target,\n      oldTarget: _hoveredTarget,\n      fireCanvas: true,\n    });\n    for (let i = 0; i < length; i++) {\n      if (\n        subTargets[i] === target ||\n        (_hoveredTargets[i] && _hoveredTargets[i] === _hoveredTarget)\n      ) {\n        continue;\n      }\n      this.fireSyntheticInOutEvents('mouse', {\n        e,\n        target: subTargets[i],\n        oldTarget: _hoveredTargets[i],\n      });\n    }\n    this._hoveredTarget = target;\n    this._hoveredTargets = subTargets;\n  }\n\n  /**\n   * Manage the dragEnter, dragLeave events for the fabric objects on the canvas\n   * @param {Fabric.Object} target the target where the target from the onDrag event\n   * @param {Object} data Event object fired on dragover\n   * @private\n   */\n  _fireEnterLeaveEvents(\n    e: TPointerEvent,\n    target: FabricObject | undefined,\n    data: DragEventData,\n  ) {\n    const draggedoverTarget = this._draggedoverTarget,\n      _hoveredTargets = this._hoveredTargets,\n      { subTargets } = this.findTarget(e),\n      length = Math.max(_hoveredTargets.length, subTargets.length);\n\n    this.fireSyntheticInOutEvents('drag', {\n      ...data,\n      target,\n      oldTarget: draggedoverTarget,\n      fireCanvas: true,\n    });\n    for (let i = 0; i < length; i++) {\n      this.fireSyntheticInOutEvents('drag', {\n        ...data,\n        target: subTargets[i],\n        oldTarget: _hoveredTargets[i],\n      });\n    }\n    this._draggedoverTarget = target;\n  }\n\n  /**\n   * Manage the synthetic in/out events for the fabric objects on the canvas\n   * @param {Fabric.Object} target the target where the target from the supported events\n   * @param {Object} data Event object fired\n   * @param {Object} config configuration for the function to work\n   * @param {String} config.targetName property on the canvas where the old target is stored\n   * @param {String} [config.canvasEvtOut] name of the event to fire at canvas level for out\n   * @param {String} config.evtOut name of the event to fire for out\n   * @param {String} [config.canvasEvtIn] name of the event to fire at canvas level for in\n   * @param {String} config.evtIn name of the event to fire for in\n   * @private\n   */\n  fireSyntheticInOutEvents<T extends keyof TSyntheticEventContext>(\n    type: T,\n    {\n      target,\n      oldTarget,\n      fireCanvas,\n      e,\n      ...data\n    }: TSyntheticEventContext[T] & {\n      target?: FabricObject;\n      oldTarget?: FabricObject;\n      fireCanvas?: boolean;\n    },\n  ) {\n    const { targetIn, targetOut, canvasIn, canvasOut } =\n      syntheticEventConfig[type];\n    const targetChanged = oldTarget !== target;\n\n    if (oldTarget && targetChanged) {\n      const outOpt: CanvasEvents[typeof canvasOut] = {\n        ...data,\n        e,\n        target: oldTarget,\n        nextTarget: target,\n        ...getEventPoints(this, e),\n      };\n      fireCanvas && this.fire(canvasOut, outOpt);\n      oldTarget.fire(targetOut, outOpt);\n    }\n    if (target && targetChanged) {\n      const inOpt: CanvasEvents[typeof canvasIn] = {\n        ...data,\n        e,\n        target,\n        previousTarget: oldTarget,\n        ...getEventPoints(this, e),\n      };\n      fireCanvas && this.fire(canvasIn, inOpt);\n      target.fire(targetIn, inOpt);\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} e Event fired on mousemove\n   */\n  _transformObject(e: TPointerEvent) {\n    const scenePoint = this.getScenePoint(e),\n      transform = this._currentTransform!,\n      target = transform.target,\n      //  transform pointer to target's containing coordinate plane\n      //  both pointer and object should agree on every point\n      localPointer = target.group\n        ? sendPointToPlane(\n            scenePoint,\n            undefined,\n            target.group.calcTransformMatrix(),\n          )\n        : scenePoint;\n    transform.shiftKey = e.shiftKey;\n    transform.altKey = !!this.centeredKey && e[this.centeredKey];\n\n    this._performTransformAction(e, transform, localPointer);\n    transform.actionPerformed && this.requestRenderAll();\n  }\n\n  /**\n   * @private\n   */\n  _performTransformAction(\n    e: TPointerEvent,\n    transform: Transform,\n    pointer: Point,\n  ) {\n    const { action, actionHandler, target } = transform;\n\n    const actionPerformed =\n      !!actionHandler && actionHandler(e, transform, pointer.x, pointer.y);\n    actionPerformed && target.setCoords();\n\n    // this object could be created from the function in the control handlers\n    if (action === 'drag' && actionPerformed) {\n      transform.target.isMoving = true;\n      this.setCursor(transform.target.moveCursor || this.moveCursor);\n    }\n    transform.actionPerformed = transform.actionPerformed || actionPerformed;\n  }\n\n  /**\n   * Sets the cursor depending on where the canvas is being hovered.\n   * Note: very buggy in Opera\n   * @param {Event} e Event object\n   * @param {Object} target Object that the mouse is hovering, if so.\n   */\n  _setCursorFromEvent(e: TPointerEvent, target?: FabricObject) {\n    if (!target) {\n      this.setCursor(this.defaultCursor);\n      return;\n    }\n    let hoverCursor = target.hoverCursor || this.hoverCursor;\n    const activeSelection = isActiveSelection(this._activeObject)\n        ? this._activeObject\n        : null,\n      // only show proper corner when group selection is not active\n      corner =\n        (!activeSelection || target.group !== activeSelection) &&\n        // here we call findTargetCorner always with undefined for the touch parameter.\n        // we assume that if you are using a cursor you do not need to interact with\n        // the bigger touch area.\n        target.findControl(this.getViewportPoint(e));\n\n    if (!corner) {\n      if ((target as Group).subTargetCheck) {\n        // hoverCursor should come from top-most subTarget,\n        // so we walk the array backwards\n        const { subTargets } = this.findTarget(e);\n        subTargets\n          .concat()\n          .reverse()\n          .forEach((_target) => {\n            hoverCursor = _target.hoverCursor || hoverCursor;\n          });\n      }\n      this.setCursor(hoverCursor);\n    } else {\n      const { control, coord } = corner;\n      this.setCursor(control.cursorStyleHandler(e, control, target, coord));\n    }\n  }\n\n  /**\n   * ## Handles multiple selection\n   * - toggles `target` selection (selects/deselects `target` if it isn't/is selected respectively)\n   * - sets the active object in case it is not set or in case there is a single active object left under active selection.\n   * ---\n   * - If the active object is the active selection we add/remove `target` from it\n   * - If not, add the active object and `target` to the active selection and make it the active object.\n   * @TODO rewrite this after find target is refactored\n   * @private\n   * @param {TPointerEvent} e Event object\n   * @param {FabricObject} target target of event to select/deselect\n   * @returns true if grouping occurred\n   */\n  protected handleMultiSelection(e: TPointerEvent, target?: FabricObject) {\n    const activeObject = this._activeObject;\n    const isAS = isActiveSelection(activeObject);\n    if (\n      // check if an active object exists on canvas and if the user is pressing the `selectionKey` while canvas supports multi selection.\n      !!activeObject &&\n      // *PMW*\n      (config.enableGroupSelection || this._isSelectionKeyPressed(e)) &&\n      this.selection &&\n      // on top of that the user also has to hit a target that is selectable.\n      !!target &&\n      target.selectable &&\n      // group target and active object only if they are different objects\n      // else we try to find a subtarget of `ActiveSelection`\n      (activeObject !== target || isAS) &&\n      //  make sure `activeObject` and `target` aren't ancestors of each other in case `activeObject` is not `ActiveSelection`\n      // if it is then we want to remove `target` from it\n      (isAS ||\n        (!target.isDescendantOf(activeObject) &&\n          !activeObject.isDescendantOf(target))) &&\n      //  target accepts selection\n      !target.onSelect({ e }) &&\n      // make sure we are not on top of a control\n      !activeObject.getActiveControl()\n    ) {\n      if (isAS) {\n        const prevActiveObjects = activeObject.getObjects();\n        let subTargets: FabricObject[] = [];\n        // const { subTargets: testSubTargets } = this.findTarget(e);\n        if (target === activeObject) {\n          const pointer = this.getScenePoint(e);\n          let targetInfo = this.searchPossibleTargets(\n            prevActiveObjects,\n            pointer,\n          );\n          // console.log(testSubTargets.includes(targetInfo.target));\n          if (targetInfo.target) {\n            target = targetInfo.target;\n            subTargets = targetInfo.subTargets;\n          } else {\n            targetInfo = this.searchPossibleTargets(this._objects, pointer);\n            target = targetInfo.target;\n            subTargets = targetInfo.subTargets;\n          }\n          // if nothing is found bail out\n          if (!target || !target.selectable) {\n            return false;\n          }\n        }\n        if (target.group === activeObject) {\n          // *PMW* . Use of custom variable. Preventing unselection of object tapped on, from active selection to enable drag. We have written custom code for unselection of object on mouse up instead of mouse down to enable dragging.\n          if (config.enableGroupSelection) {\n            return;\n          }\n\n          // `target` is part of active selection => remove it\n          activeObject.remove(target);\n          this._hoveredTarget = target;\n          this._hoveredTargets = subTargets;\n          // if after removing an object we are left with one only...\n          if (activeObject.size() === 1) {\n            // activate last remaining object\n            // deselecting the active selection will remove the remaining object from it\n            this._setActiveObject(activeObject.item(0), e);\n          }\n        } else {\n          // `target` isn't part of active selection => add it\n          activeObject.multiSelectAdd(target);\n          this._hoveredTarget = activeObject;\n          this._hoveredTargets = subTargets;\n        }\n        this._fireSelectionEvents(prevActiveObjects, e);\n      } else {\n        (activeObject as IText).isEditing &&\n          (activeObject as IText).exitEditing();\n        // add the active object and the target to the active selection and set it as the active object\n        const klass =\n          classRegistry.getClass<typeof ActiveSelection>('ActiveSelection');\n        const newActiveSelection = new klass([], {\n          /**\n           * it is crucial to pass the canvas ref before calling {@link ActiveSelection#multiSelectAdd}\n           * since it uses {@link FabricObject#isInFrontOf} which relies on the canvas ref\n           */\n          canvas: this,\n        });\n        newActiveSelection.multiSelectAdd(activeObject, target);\n        this._hoveredTarget = newActiveSelection;\n        // ISSUE 4115: should we consider subTargets here?\n        // this._hoveredTargets = [];\n        // this._hoveredTargets = this.targets.concat();\n        this._setActiveObject(newActiveSelection, e);\n        this._fireSelectionEvents([activeObject], e);\n      }\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * ## Handles selection\n   * - selects objects that are contained in (and possibly intersecting) the selection bounding box\n   * - sets the active object\n   * ---\n   * runs on mouse up after a mouse move\n   */\n  protected handleSelection(e: TPointerEvent) {\n    if (!this.selection || !this._groupSelector) {\n      return false;\n    }\n    const { x, y, deltaX, deltaY } = this._groupSelector,\n      point1 = new Point(x, y),\n      point2 = point1.add(new Point(deltaX, deltaY)),\n      tl = point1.min(point2),\n      br = point1.max(point2),\n      size = br.subtract(tl);\n\n    const collectedObjects = this.collectObjects(\n      {\n        left: tl.x,\n        top: tl.y,\n        width: size.x,\n        height: size.y,\n      },\n      { includeIntersecting: !this.selectionFullyContained },\n    ) as FabricObject[];\n\n    const objects =\n      // though this method runs only after mouse move the pointer could do a mouse up on the same position as mouse down\n      // should it be handled as is?\n      point1.eq(point2)\n        ? collectedObjects[0]\n          ? [collectedObjects[0]]\n          : []\n        : collectedObjects.length > 1\n          ? collectedObjects\n              .filter((object) => !object.onSelect({ e }))\n              .reverse()\n          : // `setActiveObject` will call `onSelect(collectedObjects[0])` in this case\n            collectedObjects;\n\n    // set active object\n    if (objects.length === 1) {\n      // set as active object\n      this.setActiveObject(objects[0], e);\n    } else if (objects.length > 1) {\n      // add to active selection and make it the active object\n      const klass =\n        classRegistry.getClass<typeof ActiveSelection>('ActiveSelection');\n      this.setActiveObject(new klass(objects, { canvas: this }), e);\n    }\n\n    // cleanup\n    this._groupSelector = null;\n    return true;\n  }\n\n  /**\n   * Wraps the original toCanvasElement with a function that removes\n   * the context top for the time the function is run.\n   * So we avoid painting side effects on the upper canvas when exporting\n   */\n  toCanvasElement(\n    multiplier = 1,\n    options?: TToCanvasElementOptions,\n  ): HTMLCanvasElement {\n    const { upper } = this.elements;\n    upper.ctx = undefined as unknown as CanvasRenderingContext2D;\n    const htmlElement = super.toCanvasElement(multiplier, options);\n    upper.ctx = upper.el.getContext('2d')!;\n    return htmlElement;\n  }\n\n  /**\n   * @override clear {@link textEditingManager}\n   */\n  clear() {\n    this.textEditingManager.clear();\n    super.clear();\n  }\n\n  /**\n   * @override clear {@link textEditingManager}\n   */\n  destroy() {\n    this.removeListeners();\n    this.textEditingManager.dispose();\n    super.destroy();\n  }\n}\n"],"names":["addEventOptions","passive","getEventPoints","canvas","e","viewportPoint","getViewportPoint","scenePoint","getScenePoint","addListener","el","_len","arguments","length","args","Array","_key","addEventListener","removeListener","_len2","_key2","removeEventListener","syntheticEventConfig","mouse","in","out","targetIn","targetOut","canvasIn","canvasOut","drag","Canvas","SelectableCanvas","constructor","super","undefined","_defineProperty","this","TextEditingManager","forEach","eventHandler","bind","addOrRemove","_getEventPrefix","enablePointerEvents","functor","forTouch","canvasElement","upperCanvasEl","eventTypePrefix","getWindowFromElement","_onResize","_onMouseDown","_onMouseMove","_onMouseOut","_onMouseEnter","_onMouseWheel","_onContextMenu","_onClick","_onDragStart","_onDragEnd","_onDragOver","_onDragEnter","_onDragLeave","_onDrop","_onTouchStart","removeListeners","doc","getDocumentFromElement","_onMouseUp","_onTouchEnd","_onTouchMove","clearTimeout","_willAddMouseDown","_cacheTransformEventData","_handleEvent","_resetTransformEventData","target","_hoveredTarget","shared","fire","_hoveredTargets","nestedTarget","findTarget","_currentTransform","_isClick","activeObject","getActiveObject","onDragStart","_dragSource","options","_onDragProgress","stopEvent","_renderDragEffects","source","dirty","dropTarget","_dropTarget","clearContextTop","ctx","contextTop","save","transform","viewportTransform","renderDragSourceEffect","restore","renderDropTargetEffect","contextTopDirty","currentSubTargets","didDrop","dataTransfer","dropEffect","NONE","_activeObject","subTargets","dragSource","_draggedoverTarget","eventType","currentContainer","canDrop","_fireEnterLeaveEvents","i","subTarget","_basicEventHandler","stopContextMenu","clicks","detail","type","fireEventFromPointerEvent","eventName","secondaryName","extraData","getPointerId","evt","changedTouches","identifier","pointerId","_isMainEvent","isPrimary","touches","mainTouchId","shouldPreventScrolling","allowTouchScrolling","currentActiveObject","__onMouseDown","isDrawingMode","preventDefault","__onMouseUp","setTimeout","shouldStartDragging","__onMouseMove","touchProps","numOfTouches","event","dx","pageX","x","dy","pageY","y","totalDrift","Math","sqrt","allowedTouchDriftDeviance","calcOffset","_shouldRender","_this$_activeObject","isClick","button","fireMiddleClick","fireRightClick","_isCurrentlyDrawing","_onMouseUpInDrawingMode","pointer","corner","shouldRender","_finalizeCurrentTransform","actionPerformed","targetWasActive","handleSelection","found","findControl","isTouchEvent","key","control","selectable","activeOn","setActiveObject","mouseUpHandler","getMouseUpHandler","call","isMoving","originalControl","controls","originalMouseUpHandler","_setCursorFromEvent","_groupSelector","__corner","requestRenderAll","isEditing","renderTop","config","isCanvasTwoFingerPanning","_onMouseDownInDrawingMode","discardActiveObject","freeDrawingBrush","onMouseDown","alreadySelected","_onMouseMoveInDrawingMode","onMouseMove","setCursor","freeDrawingCursor","onMouseUp","grouped","handleMultiSelection","_shouldClearSelection","selection","disableGroupSelector","p","deltaY","deltaX","handle","enableGroupSelection","_setupCurrentTransform","mouseDownHandler","getMouseDownHandler","_objectsToRender","_targetInfo","_viewportPoint","_scenePoint","sendPointToPlane","groupSelector","_transformObject","_fireOverOutEvents","textEditingManager","max","fireSyntheticInOutEvents","oldTarget","fireCanvas","data","draggedoverTarget","_ref","targetChanged","outOpt","nextTarget","inOpt","previousTarget","localPointer","group","calcTransformMatrix","shiftKey","altKey","centeredKey","_performTransformAction","action","actionHandler","setCoords","moveCursor","defaultCursor","hoverCursor","activeSelection","isActiveSelection","coord","cursorStyleHandler","subTargetCheck","concat","reverse","_target","isAS","_isSelectionKeyPressed","isDescendantOf","onSelect","getActiveControl","prevActiveObjects","getObjects","targetInfo","searchPossibleTargets","_objects","remove","size","_setActiveObject","item","multiSelectAdd","_fireSelectionEvents","exitEditing","newActiveSelection","classRegistry","getClass","point1","Point","point2","add","tl","min","subtract","collectedObjects","collectObjects","left","top","width","height","includeIntersecting","selectionFullyContained","objects","eq","filter","object","klass","toCanvasElement","multiplier","upper","elements","htmlElement","getContext","clear","destroy","dispose"],"mappings":"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"}