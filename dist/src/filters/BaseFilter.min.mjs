import{defineProperty as e}from"../../_virtual/_rollupPluginBabelHelpers.min.mjs";import{getEnv as t}from"../env/index.min.mjs";import{isWebGLPipelineState as r}from"./utils.min.mjs";import{identityFragmentShader as o,vertexSource as i,highPsourceCode as a}from"./shaders/baseFilter.min.mjs";import{FabricError as n}from"../util/internals/console.min.mjs";import{createCanvasElementFor as s}from"../util/misc/dom.min.mjs";const u=new RegExp(a,"g");class c{get type(){return this.constructor.type}constructor(){let{type:e,...t}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};Object.assign(this,this.constructor.defaults,t)}getFragmentSource(){return o}getVertexSource(){return i}createProgram(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.getFragmentSource(),o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.getVertexSource();const{WebGLProbe:{GLPrecision:i="highp"}}=t();"highp"!==i&&(r=r.replace(u,a.replace("highp",i)));const s=e.createShader(e.VERTEX_SHADER),c=e.createShader(e.FRAGMENT_SHADER),h=e.createProgram();if(!s||!c||!h)throw new n("Vertex, fragment shader or program creation error");if(e.shaderSource(s,o),e.compileShader(s),!e.getShaderParameter(s,e.COMPILE_STATUS))throw new n(`Vertex shader compile error for ${this.type}: ${e.getShaderInfoLog(s)}`);if(e.shaderSource(c,r),e.compileShader(c),!e.getShaderParameter(c,e.COMPILE_STATUS))throw new n(`Fragment shader compile error for ${this.type}: ${e.getShaderInfoLog(c)}`);if(e.attachShader(h,s),e.attachShader(h,c),e.linkProgram(h),!e.getProgramParameter(h,e.LINK_STATUS))throw new n(`Shader link error for "${this.type}" ${e.getProgramInfoLog(h)}`);const m=this.getUniformLocations(e,h)||{};return m.uStepW=e.getUniformLocation(h,"uStepW"),m.uStepH=e.getUniformLocation(h,"uStepH"),{program:h,attributeLocations:this.getAttributeLocations(e,h),uniformLocations:m}}getAttributeLocations(e,t){return{aPosition:e.getAttribLocation(t,"aPosition")}}getUniformLocations(e,t){const r=this.constructor.uniformLocations,o={};for(let i=0;i<r.length;i++)o[r[i]]=e.getUniformLocation(t,r[i]);return o}sendAttributeData(e,t,r){const o=t.aPosition,i=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,i),e.enableVertexAttribArray(o),e.vertexAttribPointer(o,2,e.FLOAT,!1,0,0),e.bufferData(e.ARRAY_BUFFER,r,e.STATIC_DRAW)}_setupFrameBuffer(e){const t=e.context;if(e.passes>1){const r=e.destinationWidth,o=e.destinationHeight;e.sourceWidth===r&&e.sourceHeight===o||(t.deleteTexture(e.targetTexture),e.targetTexture=e.filterBackend.createTexture(t,r,o)),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e.targetTexture,0)}else t.bindFramebuffer(t.FRAMEBUFFER,null),t.finish()}_swapTextures(e){e.passes--,e.pass++;const t=e.targetTexture;e.targetTexture=e.sourceTexture,e.sourceTexture=t}isNeutralState(e){return!1}applyTo(e){r(e)?(this._setupFrameBuffer(e),this.applyToWebGL(e),this._swapTextures(e)):this.applyTo2d(e)}applyTo2d(e){}getCacheKey(){return this.type}retrieveShader(e){const t=this.getCacheKey();return e.programCache[t]||(e.programCache[t]=this.createProgram(e.context)),e.programCache[t]}applyToWebGL(e){const t=e.context,r=this.retrieveShader(e);0===e.pass&&e.originalTexture?t.bindTexture(t.TEXTURE_2D,e.originalTexture):t.bindTexture(t.TEXTURE_2D,e.sourceTexture),t.useProgram(r.program),this.sendAttributeData(t,r.attributeLocations,e.aPosition),t.uniform1f(r.uniformLocations.uStepW,1/e.sourceWidth),t.uniform1f(r.uniformLocations.uStepH,1/e.sourceHeight),this.sendUniformData(t,r.uniformLocations),t.viewport(0,0,e.destinationWidth,e.destinationHeight),t.drawArrays(t.TRIANGLE_STRIP,0,4)}bindAdditionalTexture(e,t,r){e.activeTexture(r),e.bindTexture(e.TEXTURE_2D,t),e.activeTexture(e.TEXTURE0)}unbindAdditionalTexture(e,t){e.activeTexture(t),e.bindTexture(e.TEXTURE_2D,null),e.activeTexture(e.TEXTURE0)}sendUniformData(e,t){}createHelpLayer(e){if(!e.helpLayer){const{sourceWidth:t,sourceHeight:r}=e,o=s({width:t,height:r});e.helpLayer=o}}toObject(){const e=Object.keys(this.constructor.defaults||{});return{type:this.type,...e.reduce(((e,t)=>(e[t]=this[t],e)),{})}}toJSON(){return this.toObject()}static async fromObject(e,t){let{type:r,...o}=e;return new this(o)}}e(c,"type","BaseFilter"),e(c,"uniformLocations",[]);export{c as BaseFilter};
//# sourceMappingURL=BaseFilter.min.mjs.map
