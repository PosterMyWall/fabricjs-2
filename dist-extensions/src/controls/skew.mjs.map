{"version":3,"file":"skew.mjs","sources":["../../../src/controls/skew.ts"],"sourcesContent":["import type {\n  ControlCursorCallback,\n  TPointerEvent,\n  Transform,\n  TransformActionHandler,\n} from '../EventTypeDefs';\nimport { resolveOrigin } from '../util/misc/resolveOrigin';\nimport { Point } from '../Point';\nimport type { TAxis, TAxisKey } from '../typedefs';\nimport {\n  degreesToRadians,\n  radiansToDegrees,\n} from '../util/misc/radiansDegreesConversion';\nimport {\n  findCornerQuadrant,\n  getLocalPoint,\n  isLocked,\n  NOT_ALLOWED_CURSOR,\n} from './util';\nimport { wrapWithFireEvent } from './wrapWithFireEvent';\nimport { wrapWithFixedAnchor } from './wrapWithFixedAnchor';\nimport {\n  CENTER,\n  SCALE_X,\n  SCALE_Y,\n  SKEWING,\n  SKEW_X,\n  SKEW_Y,\n} from '../constants';\n\nexport type SkewTransform = Transform & { skewingSide: -1 | 1 };\n\nconst AXIS_KEYS: Record<\n  TAxis,\n  {\n    counterAxis: TAxis;\n    scale: TAxisKey<'scale'>;\n    skew: TAxisKey<'skew'>;\n    lockSkewing: TAxisKey<'lockSkewing'>;\n    origin: TAxisKey<'origin'>;\n    flip: TAxisKey<'flip'>;\n  }\n> = {\n  x: {\n    counterAxis: 'y',\n    scale: SCALE_X,\n    skew: SKEW_X,\n    lockSkewing: 'lockSkewingX',\n    origin: 'originX',\n    flip: 'flipX',\n  },\n  y: {\n    counterAxis: 'x',\n    scale: SCALE_Y,\n    skew: SKEW_Y,\n    lockSkewing: 'lockSkewingY',\n    origin: 'originY',\n    flip: 'flipY',\n  },\n};\n\nconst skewMap = ['ns', 'nesw', 'ew', 'nwse'];\n\n/**\n * return the correct cursor style for the skew action\n * @param {Event} eventData the javascript event that is causing the scale\n * @param {Control} control the control that is interested in the action\n * @param {FabricObject} fabricObject the fabric object that is interested in the action\n * @return {String} a valid css string for the cursor\n */\nexport const skewCursorStyleHandler: ControlCursorCallback = (\n  eventData,\n  control,\n  fabricObject,\n) => {\n  if (control.x !== 0 && isLocked(fabricObject, 'lockSkewingY')) {\n    return NOT_ALLOWED_CURSOR;\n  }\n  if (control.y !== 0 && isLocked(fabricObject, 'lockSkewingX')) {\n    return NOT_ALLOWED_CURSOR;\n  }\n  const n = findCornerQuadrant(fabricObject, control) % 4;\n  return `${skewMap[n]}-resize`;\n};\n\n/**\n * Since skewing is applied before scaling, calculations are done in a scaleless plane\n * @see https://github.com/fabricjs/fabric.js/pull/8380\n */\nfunction skewObject(\n  axis: TAxis,\n  { target, ex, ey, skewingSide, ...transform }: SkewTransform,\n  pointer: Point,\n) {\n  const { skew: skewKey } = AXIS_KEYS[axis],\n    offset = pointer\n      .subtract(new Point(ex, ey))\n      .divide(new Point(target.scaleX, target.scaleY))[axis],\n    skewingBefore = target[skewKey],\n    skewingStart = transform[skewKey],\n    shearingStart = Math.tan(degreesToRadians(skewingStart)),\n    // let a, b be the size of target\n    // let a' be the value of a after applying skewing\n    // then:\n    // a' = a + b * skewA => skewA = (a' - a) / b\n    // the value b is tricky since skewY is applied before skewX\n    b =\n      axis === 'y'\n        ? target._getTransformedDimensions({\n            scaleX: 1,\n            scaleY: 1,\n            // since skewY is applied before skewX, b (=width) is not affected by skewX\n            skewX: 0,\n          }).x\n        : target._getTransformedDimensions({\n            scaleX: 1,\n            scaleY: 1,\n          }).y;\n\n  const shearing =\n    (2 * offset * skewingSide) /\n      // we max out fractions to safeguard from asymptotic behavior\n      Math.max(b, 1) +\n    // add starting state\n    shearingStart;\n\n  const skewing = radiansToDegrees(Math.atan(shearing));\n\n  target.set(skewKey, skewing);\n  const changed = skewingBefore !== target[skewKey];\n\n  if (changed && axis === 'y') {\n    // we don't want skewing to affect scaleX\n    // so we factor it by the inverse skewing diff to make it seem unchanged to the viewer\n    const { skewX, scaleX } = target,\n      dimBefore = target._getTransformedDimensions({ skewY: skewingBefore }),\n      dimAfter = target._getTransformedDimensions(),\n      compensationFactor = skewX !== 0 ? dimBefore.x / dimAfter.x : 1;\n    compensationFactor !== 1 &&\n      target.set(SCALE_X, compensationFactor * scaleX);\n  }\n\n  return changed;\n}\n\n/**\n * Wrapped Action handler for skewing on a given axis, takes care of the\n * skew direction and determines the correct transform origin for the anchor point\n * @param {Event} eventData javascript event that is doing the transform\n * @param {Object} transform javascript object containing a series of information around the current transform\n * @param {number} x current mouse x position, canvas normalized\n * @param {number} y current mouse y position, canvas normalized\n * @return {Boolean} true if some change happened\n */\nfunction skewHandler(\n  axis: TAxis,\n  eventData: TPointerEvent,\n  transform: Transform,\n  x: number,\n  y: number,\n) {\n  const { target } = transform,\n    {\n      counterAxis,\n      origin: originKey,\n      lockSkewing: lockSkewingKey,\n      skew: skewKey,\n      flip: flipKey,\n    } = AXIS_KEYS[axis];\n  if (isLocked(target, lockSkewingKey)) {\n    return false;\n  }\n\n  const { origin: counterOriginKey, flip: counterFlipKey } =\n      AXIS_KEYS[counterAxis],\n    counterOriginFactor =\n      resolveOrigin(transform[counterOriginKey]) *\n      (target[counterFlipKey] ? -1 : 1),\n    // if the counter origin is top/left (= -0.5) then we are skewing x/y values on the bottom/right side of target respectively.\n    // if the counter origin is bottom/right (= 0.5) then we are skewing x/y values on the top/left side of target respectively.\n    // skewing direction on the top/left side of target is OPPOSITE to the direction of the movement of the pointer,\n    // so we factor skewing direction by this value.\n    skewingSide = (-Math.sign(counterOriginFactor) *\n      (target[flipKey] ? -1 : 1)) as 1 | -1,\n    skewingDirection =\n      ((target[skewKey] === 0 &&\n        // in case skewing equals 0 we use the pointer offset from target center to determine the direction of skewing\n        getLocalPoint(transform, CENTER, CENTER, x, y)[axis] > 0) ||\n      // in case target has skewing we use that as the direction\n      target[skewKey] > 0\n        ? 1\n        : -1) * skewingSide,\n    // anchor to the opposite side of the skewing direction\n    // normalize value from [-1, 1] to origin value [0, 1]\n    origin = -skewingDirection * 0.5 + 0.5;\n\n  const finalHandler = wrapWithFireEvent<SkewTransform>(\n    SKEWING,\n    wrapWithFixedAnchor((eventData, transform, x, y) =>\n      skewObject(axis, transform, new Point(x, y)),\n    ),\n  );\n\n  return finalHandler(\n    eventData,\n    {\n      ...transform,\n      [originKey]: origin,\n      skewingSide,\n    },\n    x,\n    y,\n  );\n}\n\n/**\n * Wrapped Action handler for skewing on the X axis, takes care of the\n * skew direction and determines the correct transform origin for the anchor point\n * @param {Event} eventData javascript event that is doing the transform\n * @param {Object} transform javascript object containing a series of information around the current transform\n * @param {number} x current mouse x position, canvas normalized\n * @param {number} y current mouse y position, canvas normalized\n * @return {Boolean} true if some change happened\n */\nexport const skewHandlerX: TransformActionHandler = (\n  eventData,\n  transform,\n  x,\n  y,\n) => {\n  return skewHandler('x', eventData, transform, x, y);\n};\n\n/**\n * Wrapped Action handler for skewing on the Y axis, takes care of the\n * skew direction and determines the correct transform origin for the anchor point\n * @param {Event} eventData javascript event that is doing the transform\n * @param {Object} transform javascript object containing a series of information around the current transform\n * @param {number} x current mouse x position, canvas normalized\n * @param {number} y current mouse y position, canvas normalized\n * @return {Boolean} true if some change happened\n */\nexport const skewHandlerY: TransformActionHandler = (\n  eventData,\n  transform,\n  x,\n  y,\n) => {\n  return skewHandler('y', eventData, transform, x, y);\n};\n"],"names":["AXIS_KEYS","x","counterAxis","scale","SCALE_X","skew","SKEW_X","lockSkewing","origin","flip","y","SCALE_Y","SKEW_Y","skewMap","skewCursorStyleHandler","eventData","control","fabricObject","isLocked","NOT_ALLOWED_CURSOR","n","findCornerQuadrant","skewObject","axis","_ref","pointer","target","ex","ey","skewingSide","transform","skewKey","offset","subtract","Point","divide","scaleX","scaleY","skewingBefore","skewingStart","shearingStart","Math","tan","degreesToRadians","b","_getTransformedDimensions","skewX","shearing","max","skewing","radiansToDegrees","atan","set","changed","dimBefore","skewY","dimAfter","compensationFactor","skewHandler","originKey","lockSkewingKey","flipKey","counterOriginKey","counterFlipKey","counterOriginFactor","resolveOrigin","sign","skewingDirection","getLocalPoint","CENTER","finalHandler","wrapWithFireEvent","SKEWING","wrapWithFixedAnchor","skewHandlerX","skewHandlerY"],"mappings":"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"}